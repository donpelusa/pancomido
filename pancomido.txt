Estructura proyecto:

/pancomido
�   .gitignore
�   eslint.config.js
�   index.html
�   package-lock.json
�   package.json
�   printFiles.js
�   README.md
�   vercel.json
�   vite.config.js
�   
+---api
�   �   cloudinaryConfig.js
�   �   index.js
�   �   jest.config.js
�   �   package-lock.json
�   �   package.json
�   �   
�   +---src
�   �   �   server.js
�   �   �   
�   �   +---config
�   �   �       db.js
�   �   �       init.sql
�   �   �       inserts.sql
�   �   �       
�   �   +---controllers
�   �   �       address.controller.js
�   �   �       adminDashboard.controller.js
�   �   �       adminProducts.controller.js
�   �   �       adminUsers.controller.js
�   �   �       auth.controller.js
�   �   �       categories.controller.js
�   �   �       favorites.controller.js
�   �   �       gateways.controller.js
�   �   �       order.controller.js
�   �   �       product.controller.js
�   �   �       user.controller.js
�   �   �       
�   �   +---docs
�   �   �   +---routes
�   �   �           swaggerConfig.js
�   �   �           swaggerSchemas.js
�   �   �           
�   �   +---helpers
�   �   �       cloudinaryHelper.js
�   �   �       
�   �   +---middlewares
�   �   �       isAdmin.js
�   �   �       validateCredentials.js
�   �   �       validateToken.js
�   �   �       
�   �   +---models
�   �   �       Address.js
�   �   �       Auth.js
�   �   �       Favorites.js
�   �   �       Product.js
�   �   �       User.js
�   �   �       
�   �   +---routes
�   �   �       address.routes.js
�   �   �       admin.routes.js
�   �   �       auth.routes.js
�   �   �       categories.routes.js
�   �   �       favorites.routes.js
�   �   �       gateways.routes.js
�   �   �       order.routes.js
�   �   �       product.routes.js
�   �   �       productImages.routes.js
�   �   �       routes.js
�   �   �       uploadRoute.js
�   �   �       user.routes.js
�   �   �       
�   �   +---services
�   �           paymentService.js
�   �           
�   +---tests
�           server.test.js
�           
+---public
�       favicon.png
�       vite.svg
�       
+---src
    �   .env
    �   App.css
    �   App.jsx
    �   index.css
    �   main.jsx
    �   
    +---assets
    �   �   react.svg
    �   �   
    �   +---images
    �   �       babka_000.jpg
    �   �       babka_001.jpg
    �   �       babka_002.jpg
    �   �       babka_003.jpg
    �   �       batido_000.jpg
    �   �       batido_001.jpg
    �   �       batido_002.jpg
    �   �       brioche_000.jpg
    �   �       brioche_001.jpg
    �   �       brioche_002.jpg
    �   �       brioche_003.jpg
    �   �       brioche_004.jpg
    �   �       brioche_005.jpg
    �   �       brioche_006.jpg
    �   �       ciabatta_000.jpg
    �   �       ciabatta_001.jpg
    �   �       ciabatta_002.jpg
    �   �       ciabatta_003.jpg
    �   �       ciabatta_004.jpg
    �   �       ciabatta_005.jpg
    �   �       equipo_000.jpg
    �   �       focaccia_000.jpg
    �   �       galleta_000.jpg
    �   �       galleta_001.jpg
    �   �       galleta_002.jpg
    �   �       galleta_003.jpg
    �   �       galleta_004.jpg
    �   �       galleta_005.jpg
    �   �       galleta_006.jpg
    �   �       galleta_007.jpg
    �   �       hogaza_000.jpg
    �   �       hogaza_001.jpg
    �   �       hogaza_002.jpg
    �   �       hogaza_003.jpg
    �   �       hogaza_004.jpg
    �   �       hogaza_005.jpg
    �   �       hogaza_006.jpg
    �   �       hogaza_007.jpg
    �   �       hogaza_008.jpg
    �   �       hogaza_009.jpg
    �   �       hogaza_010.jpg
    �   �       hogaza_011.jpg
    �   �       hogaza_012.jpg
    �   �       hogaza_013.jpg
    �   �       hogaza_014.jpg
    �   �       hogaza_nuez_000.jpg
    �   �       hogaza_nuez_001.jpg
    �   �       hogaza_nuez_002.jpg
    �   �       horno_000.jpg
    �   �       horno_001.jpg
    �   �       insumos_000.jpg
    �   �       insumos_001.jpg
    �   �       kuchen_000.jpg
    �   �       lemon_pie_000.jpg
    �   �       lemon_pie_001.jpg
    �   �       lemon_pie_002.jpg
    �   �       logoRedondo_cortado.png
    �   �       logoWeb.png
    �   �       logoWeb_cortado.png
    �   �       logoWeb_cortado_collapse.png
    �   �       marca_000.jpg
    �   �       marca_001.jpg
    �   �       marca_002.jpg
    �   �       marca_003.jpg
    �   �       marca_004.jpg
    �   �       marca_005.jpg
    �   �       marca_006.jpg
    �   �       marca_007.jpg
    �   �       marca_008.jpg
    �   �       masa_000.jpg
    �   �       masa_001.jpg
    �   �       masa_002.jpg
    �   �       masa_003.jpg
    �   �       masa_004.jpg
    �   �       masa_madre_000.jpg
    �   �       masa_madre_001.jpg
    �   �       miti_mota_000.jpg
    �   �       miti_mota_001.jpg
    �   �       molde_000.jpg
    �   �       molde_centeno_000.jpg
    �   �       molde_integral_000.jpg
    �   �       molde_integral_001.jpg
    �   �       molde_integral_002.jpg
    �   �       molde_integral_003.jpg
    �   �       molde_integral_004.jpg
    �   �       molde_multisemilla_000.jpg
    �   �       molde_multisemilla_001.jpg
    �   �       pancito_404.png
    �   �       prepizza_000.jpg
    �   �       prepizza_001.jpg
    �   �       prepizza_002.jpg
    �   �       slide-001.jpg
    �   �       slide-002.jpg
    �   �       slide-003.jpg
    �   �       slide-004.jpg
    �   �       slide-005.jpg
    �   �       snicker_pie_000.jpg
    �   �       tienda_000.jpg
    �   �       
    �   +---videos
    �           login.mp4
    �           promo.mp4
    �           register.mp4
    �           
    +---components
    �   �   Categories.jsx
    �   �   Credits.jsx
    �   �   Footer.jsx
    �   �   Header.jsx
    �   �   LoginForm.jsx
    �   �   Marques.jsx
    �   �   ProductForm.jsx
    �   �   RegisterForm.jsx
    �   �   SearchBar.jsx
    �   �   
    �   +---admin
    �   �       EditarCatalogo.jsx
    �   �       EditarUsuarios.jsx
    �   �       PedidosHistoricos.jsx
    �   �       PedidosPendientes.jsx
    �   �       ProductForm.jsx
    �   �       ResumenTienda.jsx
    �   �       
    �   +---customer
    �           MiCuenta.jsx
    �           MisDatos.jsx
    �           MisDirecciones.jsx
    �           MisFavoritos.jsx
    �           MisPedidos.jsx
    �           
    +---context
    �       AuthProvider.jsx
    �       CartProvider.jsx
    �       ProductProvider.jsx
    �       
    +---data
    �       images.json
    �       promo.json
    �       slides.json
    �       userTest.json
    �       
    +---guard
    �       AuthGuard.jsx
    �       
    +---helpers
    �       api.jsx
    �       cloudinaryUpload.jsx
    �       fakeStoreAPI.jsx
    �       getProductData.helper.js
    �       roles.jsx
    �       
    +---hooks
    �       useAuth.jsx
    �       useCart.jsx
    �       useEncrypt.jsx
    �       useProductImages.jsx
    �       useProducts.jsx
    �       useStorage.jsx
    �       
    +---layouts
    �       AdminLayout.jsx
    �       AuthLayout.jsx
    �       MainLayout.jsx
    �       
    +---pages
    �       CartPage.jsx
    �       CatalogPage.jsx
    �       CheckoutPage.jsx
    �       ContactPage.jsx
    �       DashboardPage.jsx
    �       HomePage.jsx
    �       LoginPage.jsx
    �       Page404.jsx
    �       ProductPage.jsx
    �       ProfilePage.jsx
    �       RegisterPage.jsx
    �       SuccessPage.jsx
    �       
    +---router
            RouterManager.jsx
            


---
 // .gitignore

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

---
---
 // api/cloudinaryConfig.js

// cloudinaryConfig.js
const cloudinary = require('cloudinary').v2;

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

module.exports = cloudinary;

---
---
 // api/index.js

// index.js
require('dotenv').config();
const app = require('./src/server');

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
    console.log(`Server Up running on ${PORT} on ${process.env.NODE_ENV} mode.`);
});

---
---
 // api/jest.config.js

// jest.config.js

module.exports = {
    testEnvironment: 'node',
    coverageDirectory: 'coverage',
    testPathIgnorePatterns: ['/node_modules/', '/dist/'],
    setupFiles: ['dotenv/config'],
};

---
---
 // api/package.json

{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "nodemon index.js",
    "start": "node index.js",
    "test": "jest --coverage"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcrypt": "^5.1.1",
    "cloudinary": "^2.5.1",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "jest": "^29.7.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "nodemon": "^3.1.9",
    "pg": "^8.13.1",
    "swagger": "^0.7.5",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1"
  }
}

---
---
 // api/src/config/db.js

// src/config/db.js
const { Pool } = require('pg');

const pool = new Pool({
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    ssl: {
        rejectUnauthorized: false, // Esto evita la validación estricta del certificado
    }
});

// Al conectar, configurar el search_path si se ha definido un esquema en el .env
pool.on('connect', (client) => {
    client.query('SET search_path TO pancomido', (err) => {
        if (err) {
            console.error('Error setting search_path:', err);
        }
        console.log("Usando schema:", process.env.DB_SCHEMA);

    });
});

pool.on('error', (err, client) => {
    console.error('Error inesperado en el pool de conexiones', err);
    process.exit(-1);
});

module.exports = {
    query: (text, params) => pool.query(text, params),
    pool
};

---
---
 // api/src/config/init.sql

-- // src/config/init.sql

--------------------------------------------------------------------------------
-- CREACIÓN DE BD y SCHEMA
--------------------------------------------------------------------------------

-- Crear el esquema pancomido (opcional)
CREATE SCHEMA IF NOT EXISTS pancomido;

-- Ajustar search_path para que las consultas se hagan por defecto en este esquema
SET search_path TO pancomido;

--------------------------------------------------------------------------------
-- CREACIÓN DE TABLAS CON REGIÓN -> PROVINCE -> CIUDAD, ÍNDICES, TIMESTAMPS Y RESTRICCIONES
--------------------------------------------------------------------------------

-- Tabla regiones
CREATE TABLE pancomido.regions (
    id          SERIAL          PRIMARY KEY,
    region      VARCHAR(100)    NOT NULL,
    created_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMP       NOT NULL DEFAULT NOW()
);


-- Tabla provinces (Provincias)
-- Cada provincia pertenece a una región.
CREATE TABLE pancomido.provinces (
    id          SERIAL          PRIMARY KEY,
    id_region   INT             NOT NULL,
    province    VARCHAR(100)    NOT NULL,
    created_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_provinces_regions FOREIGN KEY (id_region) 
        REFERENCES pancomido.regions(id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT
);

-- Índice en provinces para id_region
CREATE INDEX idx_provinces_id_region ON pancomido.provinces (id_region);

-- Tabla ciudades
-- Cada ciudad pertenece a una provincia.
CREATE TABLE pancomido.cities (
    id          SERIAL          PRIMARY KEY,
    id_province INT             NOT NULL,
    city        VARCHAR(100)    NOT NULL,
    created_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_cities_provinces FOREIGN KEY (id_province) 
        REFERENCES pancomido.provinces(id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT
);

-- Índice en cities para id_province
CREATE INDEX idx_cities_id_province ON pancomido.cities (id_province);

-- Tabla roles
CREATE TABLE pancomido.roles (
    id SERIAL PRIMARY KEY,
    role VARCHAR(20) NOT NULL UNIQUE
);

-- Tabla usuarios
CREATE TABLE pancomido.users (
    id          SERIAL          PRIMARY KEY,
    rut         VARCHAR(20)     UNIQUE,
    name        VARCHAR(50)     NOT NULL,
    lastname    VARCHAR(50)     NOT NULL,
    phone       VARCHAR(20),
    mail        VARCHAR(100)    NOT NULL UNIQUE,
    password    VARCHAR(200)    NOT NULL,
    role_id     INT             NOT NULL DEFAULT 1,
    disabled    BOOLEAN         NOT NULL DEFAULT FALSE,
    created_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_users_roles FOREIGN KEY (role_id) 
        REFERENCES pancomido.roles(id)
);

-- Índice en users para role_id (si es necesario filtrar por rol)
CREATE INDEX idx_users_role_id ON pancomido.users (role_id);

-- Tabla de solicitudes de reseteo de contraseña

CREATE TABLE pancomido.password_reset_requests (
    id SERIAL PRIMARY KEY,
    email VARCHAR(100) NOT NULL,
    reset_code VARCHAR(6) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);




-- Tabla direcciones
CREATE TABLE pancomido.address (
    id          SERIAL          PRIMARY KEY,
    id_user     INT             NOT NULL,
    id_city     INT             NOT NULL,
    address     VARCHAR(200)    NOT NULL,
    postal_code VARCHAR(10),
    created_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    main        BOOLEAN         NOT NULL DEFAULT FALSE,
    CONSTRAINT fk_address_users FOREIGN KEY (id_user) 
        REFERENCES pancomido.users(id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT fk_address_cities FOREIGN KEY (id_city) 
        REFERENCES pancomido.cities(id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT
);


-- Índices en address para id_user e id_city
CREATE INDEX idx_address_id_user ON pancomido.address (id_user);
CREATE INDEX idx_address_id_city ON pancomido.address (id_city);

-- Tabla productos
-- Tabla productos
CREATE TABLE pancomido.products (
    id           SERIAL          PRIMARY KEY,
    product      VARCHAR(100)    NOT NULL,
    ingredients  TEXT,
    price        INTEGER         NOT NULL CHECK (price >= 0),
    weight       INTEGER         CHECK (weight >= 0),
    description  TEXT,
    nutrition    TEXT,
    available    BOOLEAN         NOT NULL DEFAULT TRUE,
    created_at   TIMESTAMP       NOT NULL DEFAULT NOW(),
    updated_at   TIMESTAMP       NOT NULL DEFAULT NOW()
);




-- Tabla pedidos
CREATE TABLE pancomido.orders (
    id                  SERIAL          PRIMARY KEY,
    id_user             INT             NOT NULL,
    id_address          INT             NOT NULL,
    order_delivery_date DATE            NOT NULL,
    order_status_id     INT             NOT NULL,
    order_address       VARCHAR(200)    NOT NULL,
    order_city          VARCHAR(100)    NOT NULL,
    order_region        VARCHAR(100)    NOT NULL,
    order_postal_code   VARCHAR(10),
    order_phone         VARCHAR(20)     NOT NULL,
    created_at          TIMESTAMP       NOT NULL DEFAULT NOW(),
    updated_at          TIMESTAMP       NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_orders_users FOREIGN KEY (id_user) 
        REFERENCES pancomido.users(id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_orders_address FOREIGN KEY (id_address) 
        REFERENCES pancomido.address(id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_orders_status FOREIGN KEY (order_status_id) 
        REFERENCES pancomido.order_status(id)
        ON UPDATE CASCADE ON DELETE RESTRICT
);

-- Índices en orders para id_user e id_address
CREATE INDEX idx_orders_id_user ON pancomido.orders (id_user);
CREATE INDEX idx_orders_id_address ON pancomido.orders (id_address);

-- Tabla pedido_detalle
CREATE TABLE pancomido.order_detail (
    id_order             INT             NOT NULL,
    id_product           INT             NOT NULL,
    units                INT             NOT NULL CHECK (units > 0),
    unit_price_product   NUMERIC(10,2)   NOT NULL CHECK (unit_price_product >= 0),
    CONSTRAINT pk_order_detail PRIMARY KEY (id_order, id_product),
    CONSTRAINT fk_detail_order FOREIGN KEY (id_order) 
        REFERENCES pancomido.orders(id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT fk_detail_product FOREIGN KEY (id_product) 
        REFERENCES pancomido.products(id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT
);

-- Índice en order_detail para id_product
CREATE INDEX idx_order_detail_id_product ON pancomido.order_detail (id_product);

-- Índice en orders para order_status_id
CREATE INDEX idx_orders_order_status_id ON pancomido.orders (order_status_id);

-- Tabla categorías
CREATE TABLE pancomido.categories (
    id          SERIAL          PRIMARY KEY,
    category    VARCHAR(100)    NOT NULL,
    created_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMP       NOT NULL DEFAULT NOW()
);

-- Tabla categoría_producto
CREATE TABLE pancomido.categories_products (
    id_product   INT NOT NULL,
    id_category  INT NOT NULL,
    CONSTRAINT pk_category_product PRIMARY KEY (id_product, id_category),
    CONSTRAINT fk_catprod_product FOREIGN KEY (id_product)  
        REFERENCES pancomido.products(id)
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT fk_catprod_category FOREIGN KEY (id_category) 
        REFERENCES pancomido.categories(id)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

-- Índices en categories_products para id_product e id_category
CREATE INDEX idx_catprod_id_product ON pancomido.categories_products (id_product);
CREATE INDEX idx_catprod_id_category ON pancomido.categories_products (id_category);

-- Tabla imágenes de producto
CREATE TABLE pancomido.product_img (
    id          SERIAL          PRIMARY KEY,
    id_product  INT             NOT NULL,
    url_img     VARCHAR(300)    NOT NULL,
    cloudinary_public_id VARCHAR(255) NOT null,
    created_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_imgprod_product FOREIGN KEY (id_product) 
        REFERENCES pancomido.products(id)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

-- Índice en product_img para id_product
CREATE INDEX idx_product_img_id_product ON pancomido.product_img (id_product);

-- Tabla stock
CREATE TABLE pancomido.stock (
    id          SERIAL          PRIMARY KEY,
    id_product  INT             NOT NULL,
    stock       INT             NOT NULL CHECK (stock >= 0),
    created_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    updated_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    CONSTRAINT fk_stock_product FOREIGN KEY (id_product) 
        REFERENCES pancomido.products(id)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);

-- Índice en stock para id_product
CREATE INDEX idx_stock_id_product ON pancomido.stock (id_product);

-- Índice en products para available (opcional, según uso en consultas)
CREATE INDEX idx_products_available ON pancomido.products (available);

--------------------------------------------------------------------------------
-- Tabla de estados de pedido (order_status)
--------------------------------------------------------------------------------
CREATE TABLE pancomido.order_status (
    id SERIAL PRIMARY KEY,
    status VARCHAR(50) NOT NULL UNIQUE,
    description VARCHAR(255) NOT NULL
);


--------------------------------------------------------------------------------
-- Tabla de lista de productos favoritos de usuario (favorites)
--------------------------------------------------------------------------------
CREATE TABLE pancomido.favorites (
    id_user     INT             NOT NULL,
    id_product  INT             NOT NULL,
    created_at  TIMESTAMP       NOT NULL DEFAULT NOW(),
    CONSTRAINT pk_favorites PRIMARY KEY (id_user, id_product),
    CONSTRAINT fk_favorites_user FOREIGN KEY (id_user)
        REFERENCES pancomido.users(id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT fk_favorites_product FOREIGN KEY (id_product)
        REFERENCES pancomido.products(id)
        ON UPDATE CASCADE ON DELETE CASCADE
);

-- Índice en favorites para id_product
CREATE INDEX idx_favorites_id_product ON pancomido.favorites (id_product);



-- Crear la función de trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at := NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- Crear triggers para cada tabla

-- Para la tabla regions
CREATE TRIGGER trg_update_regions_updated_at
BEFORE UPDATE ON pancomido.regions
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Para la tabla provinces
CREATE TRIGGER trg_update_provinces_updated_at
BEFORE UPDATE ON pancomido.provinces
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Para la tabla cities
CREATE TRIGGER trg_update_cities_updated_at
BEFORE UPDATE ON pancomido.cities
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Para la tabla users
CREATE TRIGGER trg_update_users_updated_at
BEFORE UPDATE ON pancomido.users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Para la tabla address
CREATE TRIGGER trg_update_address_updated_at
BEFORE UPDATE ON pancomido.address
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Para la tabla products
CREATE TRIGGER trg_update_products_updated_at
BEFORE UPDATE ON pancomido.products
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Para la tabla orders
CREATE TRIGGER trg_update_orders_updated_at
BEFORE UPDATE ON pancomido.orders
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Para la tabla categories
CREATE TRIGGER trg_update_categories_updated_at
BEFORE UPDATE ON pancomido.categories
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Para la tabla product_img
CREATE TRIGGER trg_update_product_img_updated_at
BEFORE UPDATE ON pancomido.product_img
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Para la tabla stock
CREATE TRIGGER trg_update_stock_updated_at
BEFORE UPDATE ON pancomido.stock
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();


---
---
 // api/src/config/inserts.sql

-- // src/config/inserts.sql

-- Insertar los status y sus descripciones
INSERT INTO pancomido.order_status (status, description) VALUES
('En revisión', 'Orden creada en sistema. En proceso de confirmación'),
('Confirmada', 'Orden confirmada. En lista de preparación'),
('En preparación', 'Orden en preparación. En proceso de empaque y listado distribución'),
('En despacho', 'Orden lista para despacho. En proceso de distribución'),
('Suspendida', 'Orden suspendida. A confirmar con cliente. Espere contacto'),
('Sin contacto', 'Entrega suspendida. Sin contacto con cliente. Favor contactar.'),
('Finalizada', 'Orden entregada y finalizada');

-- Insertar los tipos de usuarios
INSERT INTO pancomido.roles (role) VALUES ('customer'), ('admin'), ('developer');

---
---
 // api/src/controllers/address.controller.js

// src/controllers/address.controller.js

const Address = require('../models/Address');

/*
    Controladores para las direcciones de los usuarios.
*/

// Crear una nueva dirección para el usuario autenticado.
const createAddress = async (req, res, next) => {
    try {
        // Verificar que el usuario esté autenticado
        if (!req.user || !req.user.id) {
            return res.status(401).json({ error: 'No autenticado. Token inválido o no proporcionado.' });
        }
        const id_user = req.user.id;    // Obtener el id del usuario autenticado
        const addressData = { ...req.body, id_user }; // Agregar el id del usuario a los datos de la dirección

        // Si el usuario está enviando main: true en la solicitud,
        // o si es la primera dirección del usuario (sin dirección principal existente)
        const existingMain = await Address.getMainAddress(id_user);
        if (addressData.main === true) {
            // Desactivar la marca principal en las otras direcciones
            await Address.unsetMainForOtherAddresses(id_user);
        } else if (!existingMain) {
            // Si no existe ninguna dirección principal, forzamos que la nueva sea principal
            addressData.main = true;
        }

        const newAddress = await Address.createAddress(addressData);    // Crear la nueva dirección
        res.status(201).json(newAddress);   // Responder con la dirección creada
    } catch (err) {
        next(err);
    }
};

// Obtener todas las direcciones del usuario autenticado.
const getAddresses = async (req, res, next) => {
    try {
        const id_user = req.user.id;    // Obtener el id del usuario autenticado
        const addresses = await Address.getAddresses(id_user);  // Obtener las direcciones del usuario
        res.json(addresses);
    } catch (err) {
        next(err);
    }
};

// Actualizar una dirección del usuario autenticado.
const updateAddress = async (req, res, next) => {
    try {
        const id_user = req.user.id;
        const { id } = req.params;  // Obtener el id de la dirección a actualizar
        // Si en el body se envía main = true, antes de actualizar desactivar en las demás
        if (req.body.main === true) {
            await Address.unsetMainForOtherAddresses(id_user, id);  // Desactivar la marca principal en las otras direcciones
        }
        const updated = await Address.updateAddress(id, id_user, req.body); // Actualizar la dirección
        if (!updated) {
            return res.status(404).json({ error: 'Dirección no encontrada' });
        }
        res.json(updated);
    } catch (err) {
        next(err);
    }
};

// Eliminar una dirección del usuario autenticado.
const deleteAddress = async (req, res, next) => {
    try {
        const id_user = req.user.id;
        const { id } = req.params;

        // Obtener la dirección a eliminar
        const addressToDelete = await Address.getAddressById(id, id_user);
        if (!addressToDelete) {
            return res.status(404).json({ error: 'Dirección no encontrada' });
        }

        // Si la dirección a eliminar es la principal (main = true)
        if (addressToDelete.main === true) {
            const addresses = await Address.getAddresses(id_user);  // Obtener todas las direcciones del usuario
            const otherAddresses = addresses.filter(addr => addr.id != id); // Filtrar y obtener las direcciones que no sean la que se eliminará

            if (otherAddresses.length === 0) {
                return res.status(400).json({ error: 'No se puede eliminar la única dirección registrada. Agrega otra dirección y luego intente nuevamente.' });
            }

            // Escoger la primera dirección de las restantes para que sea la nueva principal.
            // Aquí se puede escoger, por ejemplo, la de menor id.
            const newMainAddress = otherAddresses.sort((a, b) => a.id - b.id)[0];

            // Actualizar esa dirección para que sea principal.
            // Se actualizan solo los campos necesarios, manteniendo los valores actuales.
            await Address.updateAddress(newMainAddress.id, id_user, {
                id_city: newMainAddress.id_city,
                address: newMainAddress.address,
                postal_code: newMainAddress.postal_code,
                main: true
            });
        }

        // Proceder a eliminar la dirección
        const deleted = await Address.deleteAddress(id, id_user);
        if (!deleted) {
            return res.status(404).json({ error: 'Dirección no encontrada' });
        }
        res.json({ message: "Dirección eliminada", deleted });
    } catch (err) {
        next(err);
    }
};

module.exports = {
    createAddress,
    getAddresses,
    updateAddress,
    deleteAddress,
};

---
---
 // api/src/controllers/adminDashboard.controller.js

const db = require('../config/db');
const schema = process.env.DB_SCHEMA;

/*
    El dashboard de administrador debe mostrar un resumen de la información más relevante de la tienda.
*/

// Función para obtener el resumen del dashboard
const getDashboardSummary = async (req, res, next) => {
    try {
        // Total de ventas del mes en curso: 
        // se calcula sumando (units * unit_price_product) de cada detalle de orden

        const salesQuery = `SELECT COALESCE(SUM(od.units * od.unit_price_product), 0) AS total_sales 
            FROM ${schema}.orders o JOIN ${schema}.order_detail od ON o.id = od.id_order 
            WHERE date_trunc('month', o.created_at) = date_trunc('month', CURRENT_DATE)`;

        // Stock global
        const stockQuery = `SELECT COALESCE(SUM(stock), 0) AS total_stock FROM ${schema}.stock`;

        // Total de pedidos del mes en curso
        const ordersQuery = `SELECT COUNT(*) AS total_orders FROM ${schema}.orders
            WHERE date_trunc('month', created_at) = date_trunc('month', CURRENT_DATE)`;

        const salesResult = await db.query(salesQuery);     // Ejecutar la consulta de ventas
        const stockResult = await db.query(stockQuery);     // Ejecutar la consulta de stock
        const ordersResult = await db.query(ordersQuery);   // Ejecutar la consulta de pedidos

        res.json({
            total_sales: salesResult.rows[0].total_sales,       // Retornar el total de ventas
            total_stock: stockResult.rows[0].total_stock,       // Retornar el total de stock
            total_orders: ordersResult.rows[0].total_orders,    // Retornar el total de pedidos
        });
    } catch (err) {
        next(err);
    }
};

module.exports = {
    getDashboardSummary,
};

---
---
 // api/src/controllers/adminProducts.controller.js

// backend/src/controllers/adminProducts.controller.js
const db = require('../config/db');
const Product = require('../models/Product');
const schema = process.env.DB_SCHEMA;
const cloudinary = require('../../cloudinaryConfig');

/**
 * Listar productos para admin.
 * Retorna cada producto con la imagen principal, stock, categorías y un arreglo "images"
 * con objetos { secure_url, public_id }.
 */
const getAdminProducts = async (req, res, next) => {
    try {
        const query = `
        SELECT 
          p.*,
          pi_main.url_img,
          (SELECT stock FROM ${schema}.stock WHERE id_product = p.id) AS stock,
          cat.categories,
          (
            SELECT array_agg(json_build_object('secure_url', url_img, 'public_id', cloudinary_public_id) ORDER BY id)
            FROM ${schema}.product_img
            WHERE id_product = p.id
          ) AS images
        FROM ${schema}.products p
        LEFT JOIN (
          SELECT DISTINCT ON (id_product) 
            id_product, 
            url_img
          FROM ${schema}.product_img
          ORDER BY id_product, id
        ) pi_main ON p.id = pi_main.id_product
        LEFT JOIN (
          SELECT 
            cp.id_product, 
            array_agg(c.category) AS categories
          FROM ${schema}.categories_products cp
          INNER JOIN ${schema}.categories c ON cp.id_category = c.id
          GROUP BY cp.id_product
        ) cat ON p.id = cat.id_product
        ORDER BY p.id;
      `;
        const { rows } = await db.query(query);
        res.json(rows);
    } catch (err) {
        next(err);
    }
};

/**
 * Crear un nuevo producto.
 * Se espera un body con:
 * {
 *   "product": "Pan Artesanal",
 *   "price": 250,
 *   "ingredients": "Harina, agua, levadura",
 *   "weight": 0.5,
 *   "description": "Descripción del producto",
 *   "nutrition": "Alto en fibra",
 *   "available": false,  // por defecto false
 *   "stock": 100,
 *   "categories": ["Categoría1", "Categoría2"],
 *   "images": [ ... ] // Opcional (para reenvío en edición)
 * }
 */
const createProduct = async (req, res, next) => {
    try {
        const { stock, categories, ...productData } = req.body;
        const newProduct = await Product.createProduct(productData);

        // Insertar stock inicial
        const initialStock = stock !== undefined ? stock : 0;
        const stockRecord = await Product.createStock(newProduct.id, initialStock);
        newProduct.stock = stockRecord.stock;

        // Insertar categorías (si se proporcionan)
        if (Array.isArray(categories)) {
            for (const catName of categories) {
                const catSelectQuery = `SELECT id FROM ${schema}.categories WHERE category = $1`;
                const catSelectResult = await db.query(catSelectQuery, [catName]);
                let catId;
                if (catSelectResult.rows.length > 0) {
                    catId = catSelectResult.rows[0].id;
                } else {
                    const catInsertQuery = `
            INSERT INTO ${schema}.categories (category)
            VALUES ($1) RETURNING id
          `;
                    const catInsertResult = await db.query(catInsertQuery, [catName]);
                    catId = catInsertResult.rows[0].id;
                }
                const cpInsertQuery = `
          INSERT INTO ${schema}.categories_products (id_product, id_category)
          VALUES ($1, $2)
        `;
                await db.query(cpInsertQuery, [newProduct.id, catId]);
            }
        }

        res.status(201).json(newProduct);
    } catch (err) {
        next(err);
    }
};

/**
 * Actualizar datos del producto, incluyendo categorías y las imágenes.
 * Se espera en el body: product, price, ingredients, weight, description, nutrition, available, categories, images.
 */
const updateProductDetails = async (req, res, next) => {
    try {
      const { id } = req.params;
      const {
        product,
        price,
        ingredients,
        weight,
        description,
        nutrition,
        available,
        categories,
        images // Se espera que, en el caso de edición, este arreglo sea enviado únicamente si hubo cambios
      } = req.body;
  
      // Actualizar datos básicos del producto
      const updateQuery = `
        UPDATE ${schema}.products
        SET product = $1,
            price = $2,
            ingredients = $3,
            weight = $4,
            description = $5,
            nutrition = $6,
            available = $7,
            updated_at = NOW()
        WHERE id = $8
        RETURNING *
      `;
      const updateValues = [product, price, ingredients, weight, description, nutrition, available, id];
      const { rows } = await db.query(updateQuery, updateValues);
      const updatedProduct = rows[0];
  
      // Actualizar categorías
      await db.query(`DELETE FROM ${schema}.categories_products WHERE id_product = $1`, [id]);
      if (Array.isArray(categories)) {
        for (const catName of categories) {
          const catSelectResult = await db.query(`SELECT id FROM ${schema}.categories WHERE category = $1`, [catName]);
          let catId;
          if (catSelectResult.rows.length > 0) {
            catId = catSelectResult.rows[0].id;
          } else {
            const catInsertResult = await db.query(
              `INSERT INTO ${schema}.categories (category) VALUES ($1) RETURNING id`,
              [catName]
            );
            catId = catInsertResult.rows[0].id;
          }
          await db.query(
            `INSERT INTO ${schema}.categories_products (id_product, id_category) VALUES ($1, $2)`,
            [id, catId]
          );
        }
      }
  
      // Actualizar imágenes solo si el payload incluye la propiedad "images"
      if (req.body.hasOwnProperty('images')) {
        // 1. Obtener las imágenes actuales de la BD para este producto
        const currentImagesResult = await db.query(
          `SELECT * FROM ${schema}.product_img WHERE id_product = $1`,
          [id]
        );
        const currentImages = currentImagesResult.rows;
        const currentPublicIds = currentImages.map(img => img.cloudinary_public_id);
  
        // 2. Procesar el arreglo enviado en el payload
        // Se espera que cada objeto en "images" tenga al menos:
        //   - secure_url (o url)
        //   - public_id
        const newImages = images; // Arreglo de imágenes enviado por el frontend
        const newPublicIds = newImages.map(img => img.public_id).filter(pid => pid);
  
        // 3. Eliminar las imágenes que ya no estén en el payload
        const imagesToDelete = currentImages.filter(
          img => !newPublicIds.includes(img.cloudinary_public_id)
        );
        for (const img of imagesToDelete) {
          try {
            await cloudinary.uploader.destroy(img.cloudinary_public_id);
          } catch (error) {
            console.error(`Error deleting image ${img.cloudinary_public_id}:`, error);
            // Se puede decidir reintentar o continuar según la política de errores
          }
          await db.query(`DELETE FROM ${schema}.product_img WHERE id = $1`, [img.id]);
        }
  
        // 4. Insertar las nuevas imágenes (aquellas que estén en el payload pero no en la BD)
        const imagesToInsert = newImages.filter(
          img => !currentPublicIds.includes(img.public_id)
        );
        for (const img of imagesToInsert) {
          // Solo insertar si se tiene tanto la URL como el public_id
          if (img.secure_url && img.public_id) {
            const insertImgQuery = `
              INSERT INTO ${schema}.product_img (id_product, url_img, cloudinary_public_id)
              VALUES ($1, $2, $3)
            `;
            await db.query(insertImgQuery, [id, img.secure_url, img.public_id]);
          }
        }
      }
      
      res.json(updatedProduct);
    } catch (err) {
      next(err);
    }
  };
  

/**
 * Actualizar stock de un producto.
 */
const updateStock = async (req, res, next) => {
    try {
        const { id } = req.params; // id del producto
        const { stock } = req.body;
        const query = `
      UPDATE ${schema}.stock
      SET stock = $1,
          updated_at = NOW()
      WHERE id_product = $2
      RETURNING *
    `;
        const { rows } = await db.query(query, [stock, id]);
        if (rows.length === 0) {
            return res.status(404).json({ error: 'Producto no encontrado en stock' });
        }
        res.json(rows[0]);
    } catch (err) {
        next(err);
    }
};

/**
 * Eliminar productos múltiples y borrar categorías huérfanas.
 * Además, elimina las imágenes asociadas en Cloudinary usando cloudinary_public_id
 * y su carpeta contenedora con el id de producto.
 */
const deleteMultipleProducts = async (req, res, next) => {
    try {
        const { productIds } = req.body;
        if (!Array.isArray(productIds) || productIds.length === 0) {
            return res.status(400).json({ error: 'Se requiere un arreglo de productIds' });
        }

        // Para cada producto a eliminar, obtener las imágenes y borrarlas de Cloudinary
        for (const productId of productIds) {
            const imageQuery = `SELECT * FROM ${schema}.product_img WHERE id_product = $1`;
            const { rows: imageRows } = await db.query(imageQuery, [productId]);
            for (const img of imageRows) {
                try {
                    await cloudinary.uploader.destroy(img.cloudinary_public_id);
                } catch (cloudErr) {
                    console.error(`Error eliminando imagen ${img.cloudinary_public_id} en Cloudinary:`, cloudErr);
                    // Se continúa con la eliminación de las demás imágenes
                }
            }
            // Intentar eliminar la carpeta asociada al producto
            try {
                await cloudinary.api.delete_folder(`productos/${productId}`);
            } catch (folderErr) {
                console.error(`Error eliminando carpeta products/${productId}:`, folderErr);
                // Nota: Si la carpeta no está vacía o no existe, se mostrará un error; puedes decidir si abortar o continuar.
            }
        }

        // Eliminar registros de imágenes en la BD
        const deleteImagesQuery = `
        DELETE FROM ${schema}.product_img
        WHERE id_product = ANY($1::int[])
      `;
        await db.query(deleteImagesQuery, [productIds]);

        // Eliminar los productos
        const deleteProductsQuery = `
        DELETE FROM ${schema}.products
        WHERE id = ANY($1::int[])
        RETURNING *
      `;
        const { rows } = await db.query(deleteProductsQuery, [productIds]);

        // Eliminar categorías huérfanas
        const orphanQuery = `
        DELETE FROM ${schema}.categories
        WHERE id NOT IN (SELECT DISTINCT id_category FROM ${schema}.categories_products)
        RETURNING *
      `;
        await db.query(orphanQuery);

        res.json({ message: 'Productos eliminados', products: rows });
    } catch (err) {
        next(err);
    }
};

module.exports = {
    getAdminProducts,
    createProduct,
    updateProductDetails,
    updateStock,
    deleteMultipleProducts,
};

---
---
 // api/src/controllers/adminUsers.controller.js

// src/controllers/adminUsers.controller.js

/*
    * Controladores para la administración de usuarios.
*/

const db = require('../config/db');
const schema = process.env.DB_SCHEMA;

// Listar todos los usuarios
const listUsers = async (req, res, next) => {
    try {
        const query = `SELECT id, rut, name, mail
            FROM ${schema}.users
            ORDER BY created_at DESC`;
        const { rows } = await db.query(query);
        res.json(rows);
    } catch (err) {
        next(err);
    }
};

// Actualizar el rol de un usuario
const updateUserRole = async (req, res, next) => {
    try {
        const { userId } = req.params;
        const { role } = req.body; // 'customer' o 'admin' o 'developer'
        const query = `UPDATE ${schema}.users
            SET role_id = (SELECT id FROM ${schema}.roles WHERE role = $1),
            updated_at = NOW()
            WHERE id = $2
            RETURNING id, name, mail, role_id`;
        const { rows } = await db.query(query, [role, userId]);
        if (rows.length === 0) {
            return res.status(404).json({ error: 'Usuario no encontrado' });
        }
        res.json(rows[0]);
    } catch (err) {
        next(err);
    }
};

// Desactivar un usuario
const disableUser = async (req, res, next) => {
    try {
        const { userId } = req.params;
        // Se asume que en la tabla users exista un campo 'disabled'
        const query = `UPDATE ${schema}.users
            SET disabled = true,
            updated_at = NOW()
            WHERE id = $1
            RETURNING id, name, mail, disabled`;
        const { rows } = await db.query(query, [userId]);
        if (rows.length === 0) {
            return res.status(404).json({ error: 'Usuario no encontrado' });
        }
        res.json(rows[0]);
    } catch (err) {
        next(err);
    }
};

// Habilitar un usuario (reactivar)
const enableUser = async (req, res, next) => {
    try {
        const { userId } = req.params;
        const query = `UPDATE ${schema}.users
            SET disabled = false,
                updated_at = NOW()
            WHERE id = $1
            RETURNING id, name, mail, disabled`;
        const { rows } = await db.query(query, [userId]);
        if (rows.length === 0) {
            return res.status(404).json({ error: 'Usuario no encontrado' });
        }
        res.json(rows[0]);
    } catch (err) {
        next(err);
    }
};

// Borrar un usuario
const deleteUser = async (req, res, next) => {
    try {
        const { userId } = req.params;
        const query = `DELETE FROM ${schema}.users
            WHERE id = $1
            RETURNING id, name, mail`;
        const { rows } = await db.query(query, [userId]);
        if (rows.length === 0) {
            return res.status(404).json({ error: 'Usuario no encontrado' });
        }
        res.json({ message: 'Usuario eliminado', user: rows[0] });
    } catch (err) {
        next(err);
    }
};

module.exports = {
    listUsers,
    updateUserRole,
    disableUser,
    enableUser,
    deleteUser,
};

---
---
 // api/src/controllers/auth.controller.js

// src/controllers/auth.controller.js

const User = require('../models/User');
const bcrypt = require('bcrypt');
const db = require('../config/db');
const crypto = require('crypto');
const SALT_ROUNDS = 10;

// Control de registro
const register = async (req, res, next) => {
    try {
        console.log("Registro iniciado:", req.body);
        const { name, lastname, mail, password } = req.body;
        if (!name || !lastname || !mail || !password) {
            console.log("Faltan campos requeridos");
            return res.status(400).json({ error: 'Faltan campos requeridos: name, lastname, mail y password.' });
        }

        console.log("Buscando usuario existente por mail:", mail);
        const existingUser = await User.findUserByMail(mail);
        console.log("Resultado de findUserByMail:", existingUser);

        if (existingUser) {
            console.log("El usuario ya existe.");
            return res.status(400).json({ error: 'El usuario ya existe.' });
        }

        console.log("Creando nuevo usuario");
        const newUser = await User.createUser({ name, lastname, mail, password });
        console.log("Usuario creado:", newUser);
        res.status(201).json(newUser);
    } catch (err) {
        console.error("Error en registro:", err);
        next(err);
    }
};

// Control de acceso
const login = async (req, res, next) => {
    try {
        const { mail, password } = req.body;
        const user = await User.findUserByMail(mail);
        if (!user) {
            return res.status(401).json({ error: 'Credenciales inválidas.' });
        }
        const isMatch = await bcrypt.compare(password, user.password);
        if (!isMatch) {
            return res.status(401).json({ error: 'Credenciales inválidas.' });
        }
        const token = require('../models/Auth').generateToken(user);
        res.json({ token });
    } catch (err) {
        next(err);
    }
};

/**
 * Reset Password Request
 * Genera un código de 6 dígitos y lo envía al correo del usuario.
 */
const resetPasswordRequest = async (req, res, next) => {
    try {
        const { email } = req.body;
        if (!email) {
            return res.status(400).json({ error: 'El campo email es requerido.' });
        }
        // Verificar que el usuario existe
        const user = await User.findUserByMail(email);
        if (!user) {
            return res.status(404).json({ error: 'No se encontró un usuario con ese email.' });
        }
        // Generar código aleatorio de 6 dígitos
        const resetCode = Math.floor(100000 + Math.random() * 900000).toString();
        // Calcular la expiración: ahora + 5 minutos
        const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

        // Insertar la solicitud en la tabla password_reset_requests
        const query = `
        INSERT INTO ${process.env.DB_SCHEMA}.password_reset_requests (email, reset_code, expires_at)
        VALUES ($1, $2, $3)
        RETURNING *
      `;
        const { rows } = await db.query(query, [email, resetCode, expiresAt]);

        // Simular el envío de correo (en producción integrar con un servicio de email)
        console.log(`Se envió el código de reseteo ${resetCode} a ${email}`);

        res.status(200).json({ message: 'Código de reseteo enviado. Valido por 5 minutos.' });
    } catch (err) {
        next(err);
    }
};

/**
 * Reset Password Confirm
 * Valida el código y actualiza la contraseña del usuario.
 */
const resetPasswordConfirm = async (req, res, next) => {
    try {
        const { email, resetCode, newPassword } = req.body;
        if (!email || !resetCode || !newPassword) {
            return res.status(400).json({ error: 'Se requieren email, resetCode y newPassword.' });
        }
        // Buscar la solicitud de reseteo para este email y código
        const query = `
        SELECT * FROM ${process.env.DB_SCHEMA}.password_reset_requests
        WHERE email = $1 AND reset_code = $2
        LIMIT 1
      `;
        const { rows } = await db.query(query, [email, resetCode]);
        if (rows.length === 0) {
            return res.status(400).json({ error: 'Código inválido o no existe.' });
        }
        const requestEntry = rows[0];
        // Verificar si el código está expirado
        if (new Date() > new Date(requestEntry.expires_at)) {
            // Eliminar la solicitud vencida
            await db.query(
                `DELETE FROM ${process.env.DB_SCHEMA}.password_reset_requests WHERE id = $1`,
                [requestEntry.id]
            );
            return res.status(400).json({ error: 'El código ha expirado.' });
        }
        // Si es válido, actualizar la contraseña del usuario
        const hashedPassword = await bcrypt.hash(newPassword, SALT_ROUNDS);
        const updateQuery = `
        UPDATE ${process.DB_SCHEMA}.users
        SET password = $1, updated_at = NOW()
        WHERE mail = $2
        RETURNING id, name, mail
      `;
        const updateResult = await db.query(updateQuery, [hashedPassword, email]);
        if (updateResult.rows.length === 0) {
            return res.status(404).json({ error: 'Usuario no encontrado.' });
        }
        // Eliminar la solicitud de reseteo una vez que se actualizó la contraseña
        await db.query(
            `DELETE FROM ${process.env.DB_SCHEMA}.password_reset_requests WHERE id = $1`,
            [requestEntry.id]
        );
        res.status(200).json({ message: 'Contraseña actualizada exitosamente.' });
    } catch (err) {
        next(err);
    }
};

module.exports = {
    register,
    login,
    resetPasswordRequest,
    resetPasswordConfirm
};

---
---
 // api/src/controllers/categories.controller.js

// src/controllers/categories.controller.js
const db = require('../config/db');
const schema = process.env.DB_SCHEMA;

const getCategories = async (req, res, next) => {
    try {
        const query = `SELECT id, category FROM ${schema}.categories ORDER BY category`;
        const { rows } = await db.query(query);
        res.json(rows);
    } catch (err) {
        next(err);
    }
};

module.exports = { getCategories };

---
---
 // api/src/controllers/favorites.controller.js

// src/controllers/favorites.controller.js

const Favorites = require('../models/Favorites');

// 
const addFavorite = async (req, res, next) => {
    try {
        const userId = req.user.id;
        const { productId } = req.body;
        if (!productId) {
            return res.status(400).json({ error: 'Se requiere productId' });
        }
        const favorite = await Favorites.addFavorite(userId, productId);
        // Si favorite es undefined, se asume que ya existía el registro.
        res.status(201).json(favorite || { message: 'Producto ya está en favoritos' });
    } catch (err) {
        next(err);
    }
};

const removeFavorite = async (req, res, next) => {
    try {
        const userId = req.user.id;
        const { productId } = req.body;
        if (!productId) {
            return res.status(400).json({ error: 'Se requiere productId' });
        }
        const removed = await Favorites.removeFavorite(userId, productId);
        if (!removed) {
            return res.status(404).json({ error: 'Favorito no encontrado' });
        }
        res.json({ message: 'Favorito eliminado', removed });
    } catch (err) {
        next(err);
    }
};

const listFavorites = async (req, res, next) => {
    try {
        const userId = req.user.id;
        const favorites = await Favorites.getFavorites(userId);
        res.json(favorites);
    } catch (err) {
        next(err);
    }
};

module.exports = {
    addFavorite,
    removeFavorite,
    listFavorites,
};


---
---
 // api/src/controllers/gateways.controller.js

// src/controllers/gateways.controller.js

const paymentService = require('../services/paymentService');

const createPayment = async (req, res, next) => {
    try {
        const paymentData = req.body;
        // Se invoca la función del paymentService para procesar el pago.
        const result = await paymentService.createPayment(paymentData);
        res.status(201).json(result);
    } catch (err) {
        next(err);
    }
};

module.exports = {
    createPayment,
};

---
---
 // api/src/controllers/order.controller.js

// src/controllers/order.controller.js

const db = require('../config/db');
const schema = process.env.DB_SCHEMA;
const User = require('../models/User');
const Address = require('../models/Address');


const createOrder = async (req, res, next) => {
    try {
        const id_user = req.user.id;
        const {
            id_address,
            order_delivery_date,
            order_status_id,
            order_address,
            order_city,
            order_region,
            order_postal_code,
            order_phone
        } = req.body;

        const query = `
        INSERT INTO ${schema}.orders (id_user, id_address, order_delivery_date, status, order_address, order_city, order_region, order_postal_code, order_phone)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING *
      `;
        const values = [
            id_user,
            id_address,
            order_delivery_date,
            order_status_id,
            order_address,
            order_city,
            order_region,
            order_postal_code || null,
            order_phone
        ];
        const { rows } = await db.query(query, values);
        res.status(201).json(rows[0]);
    } catch (err) {
        next(err);
    }
};

const getOrders = async (req, res, next) => {
    try {
        // Endpoint básico para pedidos del cliente
        const id_user = req.user.id;
        const query = `
        SELECT * FROM ${schema}.orders
        WHERE id_user = $1
        ORDER BY created_at DESC
      `;
        const { rows } = await db.query(query, [id_user]);
        res.json(rows);
    } catch (err) {
        next(err);
    }
};

const getOrderById = async (req, res, next) => {
    try {
        const id_user = req.user.id;
        const { id } = req.params;
        const query = `
        SELECT * FROM ${schema}.orders
        WHERE id = $1 AND id_user = $2
      `;
        const { rows } = await db.query(query, [id, id_user]);
        if (rows.length === 0) {
            return res.status(404).json({ error: 'Pedido no encontrado.' });
        }
        res.json(rows[0]);
    } catch (err) {
        next(err);
    }
};

// Endpoint para clientes: Listado detallado de sus pedidos
const getDetailedOrders = async (req, res, next) => {
    try {
        const id_user = req.user.id;
        const query = `
        SELECT 
          o.*,
          u.mail as user_mail,
          COALESCE(SUM(od.units * od.unit_price_product), 0) AS total_purchase,
          json_agg(json_build_object(
            'productId', od.id_product,
            'units', od.units,
            'unit_price', od.unit_price_product,
            'product', p.product,
            'ingredients', p.ingredients
          )) AS products
        FROM ${schema}.orders o
        JOIN ${schema}.users u ON o.id_user = u.id
        LEFT JOIN ${schema}.order_detail od ON o.id = od.id_order
        LEFT JOIN ${schema}.products p ON od.id_product = p.id
        WHERE o.id_user = $1
        GROUP BY o.id, u.mail
        ORDER BY o.created_at DESC
      `;
        const { rows } = await db.query(query, [id_user]);
        res.json(rows);
    } catch (err) {
        next(err);
    }
};

// Endpoints para administración: Pedidos pendientes y históricos
const getAdminPendingOrders = async (req, res, next) => {
    try {
        // Obtener el id del estado "Finalizada"
        const finalStatusResult = await db.query(
            `SELECT id FROM ${schema}.order_status WHERE status = 'Finalizada'`
        );
        if (finalStatusResult.rows.length === 0) {
            return res.status(500).json({ error: 'No se encontró el estado "Finalizada".' });
        }
        const finalStatusId = finalStatusResult.rows[0].id;

        // Consulta para obtener pedidos pendientes (no Finalizados)
        const query = `
        SELECT 
            o.*, 
            u.name || ' ' || u.lastname AS customer,
            u.mail,
            u.rut,
            json_agg(json_build_object(
                'productId', od.id_product,
                'units', od.units,
                'unit_price', od.unit_price_product
            )) AS products
        FROM ${schema}.orders o
        JOIN ${schema}.users u ON o.id_user = u.id
        LEFT JOIN ${schema}.order_detail od ON o.id = od.id_order
        WHERE o.order_status_id != $1
        GROUP BY o.id, u.name, u.lastname, u.mail, u.rut
        ORDER BY o.created_at DESC
        `;
        const { rows } = await db.query(query, [finalStatusId]);
        res.json(rows);
    } catch (err) {
        next(err);
    }
};

const getAdminHistoricalOrders = async (req, res, next) => {
    try {
        const query = `
        SELECT o.*, 
               u.name || ' ' || u.lastname AS customer,
               u.mail,
               u.rut,
               json_agg(json_build_object(
                 'productId', od.id_product,
                 'units', od.units,
                 'unit_price', od.unit_price_product
               )) AS products
        FROM ${schema}.orders o
        JOIN ${schema}.users u ON o.id_user = u.id
        LEFT JOIN ${schema}.order_detail od ON o.id = od.id_order
        WHERE o.order_status_id = (SELECT id FROM ${schema}.order_status WHERE status = 'Finalizada')
        GROUP BY o.id, u.name, u.lastname, u.mail, u.rut
        ORDER BY o.created_at DESC
      `;
        const { rows } = await db.query(query);
        res.json(rows);
    } catch (err) {
        next(err);
    }
};

const confirmPurchase = async (req, res, next) => {
    const client = await db.pool.connect();
    try {
        const id_user = req.user.id;
        // Validar que el usuario tenga datos completos (RUT y teléfono) y al menos una dirección registrada
        const user = await User.findUserById(id_user);
        if (!user.rut || !user.phone) {
            return res.status(400).json({ error: 'Para comprar, debe actualizar su perfil con RUT y teléfono.' });
        }
        const addresses = await Address.getAddresses(id_user);
        if (!addresses || addresses.length === 0) {
            return res.status(400).json({ error: 'Para comprar, debe registrar al menos una dirección.' });
        }

        // Iniciar transacción
        await client.query('BEGIN');

        const {
            id_address,
            order_delivery_date,
            order_address,
            order_city,
            order_region,
            order_postal_code,
            order_phone,
            items
        } = req.body;

        if (!items || !Array.isArray(items) || items.length === 0) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'No se han enviado items para la orden.' });
        }

        // Verificar stock para cada producto (con bloqueo FOR UPDATE)
        const insufficient = [];
        for (const item of items) {
            const { productId, units } = item;
            const stockResult = await client.query(
                `SELECT stock FROM ${schema}.stock WHERE id_product = $1 FOR UPDATE`,
                [productId]
            );
            if (stockResult.rows.length === 0) {
                insufficient.push({ productId, available: 0, requested: units });
            } else {
                const available = stockResult.rows[0].stock;
                if (available < units) {
                    insufficient.push({ productId, available, requested: units });
                }
            }
        }

        if (insufficient.length > 0) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Stock insuficiente en algunos productos', details: insufficient });
        }

        // Actualizar stock para cada producto
        for (const item of items) {
            const { productId, units } = item;
            await client.query(
                `UPDATE ${schema}.stock SET stock = stock - $1, updated_at = NOW() WHERE id_product = $2`,
                [units, productId]
            );
        }

        // Insertar la orden (se establece el estado inicial en 1, correspondiente a "En revisión" según tu tabla)
        const orderQuery = `
          INSERT INTO ${schema}.orders 
          (id_user, id_address, order_delivery_date, order_status_id, order_address, order_city, order_region, order_postal_code, order_phone)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
          RETURNING *
        `;
        const orderValues = [
            id_user,
            id_address,
            order_delivery_date,
            1, // Estado inicial: "En revisión"
            order_address,
            order_city,
            order_region,
            order_postal_code || null,
            order_phone
        ];
        const orderResult = await client.query(orderQuery, orderValues);
        const orderId = orderResult.rows[0].id;

        // Insertar cada detalle de la orden
        for (const item of items) {
            const { productId, units, unit_price } = item;
            const detailQuery = `
              INSERT INTO ${schema}.order_detail (id_order, id_product, units, unit_price_product)
              VALUES ($1, $2, $3, $4)
            `;
            await client.query(detailQuery, [orderId, productId, units, unit_price]);
        }

        await client.query('COMMIT');
        res.status(201).json({ message: 'Orden procesada exitosamente', order: orderResult.rows[0] });
    } catch (err) {
        await client.query('ROLLBACK');
        next(err);
    } finally {
        client.release();
    }
};


module.exports = {
    createOrder,
    getOrders,
    getOrderById,
    getDetailedOrders,
    getAdminPendingOrders,
    getAdminHistoricalOrders,
    confirmPurchase,
};

---
---
 // api/src/controllers/product.controller.js

// src/controllers/product.controller.js

const db = require('../config/db');
const schema = process.env.DB_SCHEMA;
const Product = require('../models/Product');

// Endpoint para listar productos públicos con filtros
const getProducts = async (req, res, next) => {
    try {
        let query;
        let params = [];

        // Si se filtra por categoría se deben incluir joins a las tablas de categorías
        if (req.query.category) {
            query = `
        SELECT DISTINCT p.*, pi.url_img
        FROM ${schema}.products p
        LEFT JOIN (
          SELECT DISTINCT ON (id_product) id_product, url_img
          FROM ${schema}.product_img
          ORDER BY id_product, id
        ) pi ON p.id = pi.id_product
        JOIN ${schema}.categories_products cp ON p.id = cp.id_product
        JOIN ${schema}.categories c ON cp.id_category = c.id
        WHERE p.available = true
      `;
            params.push(req.query.category);
            query += ` AND c.category = $${params.length}`;
            if (req.query.search) {
                params.push(`%${req.query.search}%`);
                query += ` AND (p.product ILIKE $${params.length} OR p.description ILIKE $${params.length})`;
            }
        } else {
            // Consulta básica sin filtro de categoría
            query = `
        SELECT p.*, pi.url_img
        FROM ${schema}.products p
        LEFT JOIN (
          SELECT DISTINCT ON (id_product) id_product, url_img
          FROM ${schema}.product_img
          ORDER BY id_product, id
        ) pi ON p.id = pi.id_product
        WHERE p.available = true
      `;
            if (req.query.search) {
                params.push(`%${req.query.search}%`);
                query += ` AND (p.product ILIKE $${params.length} OR p.description ILIKE $${params.length})`;
            }
        }
        query += ' ORDER BY p.id';

        const { rows } = await db.query(query, params);
        res.json(rows);
    } catch (err) {
        next(err);
    }
};

// Endpoint para la vista detalle de producto con información extendida
const getProductDetail = async (req, res, next) => {
    try {
        const { id } = req.params;
        // Obtener la información básica del producto y el stock actual
        const productQuery = `
          SELECT p.*, 
                 (SELECT stock FROM ${schema}.stock WHERE id_product = p.id) AS stock
          FROM ${schema}.products p
          WHERE p.id = $1
        `;
        const productResult = await db.query(productQuery, [id]);
        const product = productResult.rows[0];
        if (!product) {
            return res.status(404).json({ error: 'Producto no encontrado.' });
        }

        // Obtener todas las imágenes del producto
        const imagesQuery = `
          SELECT url_img FROM ${schema}.product_img
          WHERE id_product = $1
          ORDER BY id
        `;
        const imagesResult = await db.query(imagesQuery, [id]);
        product.images = imagesResult.rows.map(row => row.url_img);

        // Obtener las categorías a las que pertenece el producto
        const categoriesQuery = `
          SELECT c.category
          FROM ${schema}.categories c
          JOIN ${schema}.categories_products cp ON c.id = cp.id_category
          WHERE cp.id_product = $1
        `;
        const categoriesResult = await db.query(categoriesQuery, [id]);
        product.categories = categoriesResult.rows.map(row => row.category);

        // Se conserva el valor real de nutrition proveniente de la BD
        // (Eliminar la línea que asignaba null)

        // Obtener productos relacionados basados en la primera categoría (si existe)
        if (product.categories.length > 0) {
            const relatedQuery = `
              SELECT DISTINCT p.id, p.product, pi.url_img
              FROM ${schema}.products p
              LEFT JOIN (
                SELECT DISTINCT ON (id_product) id_product, url_img
                FROM ${schema}.product_img
                ORDER BY id_product, id
              ) pi ON p.id = pi.id_product
              JOIN ${schema}.categories_products cp ON p.id = cp.id_product
              JOIN ${schema}.categories c ON cp.id_category = c.id
              WHERE c.category = $1
                AND p.id <> $2
                AND p.available = true
              LIMIT 5
            `;
            const relatedResult = await db.query(relatedQuery, [product.categories[0], id]);
            product.related = relatedResult.rows;
        } else {
            product.related = [];
        }

        res.json(product);
    } catch (err) {
        next(err);
    }
};


const createProduct = async (req, res, next) => {
    try {
        const newProduct = await Product.createProduct(req.body);
        res.status(201).json(newProduct);
    } catch (err) {
        next(err);
    }
};

const updateProduct = async (req, res, next) => {
    try {
        const updatedProduct = await Product.updateProduct(req.params.id, req.body);
        if (!updatedProduct) {
            return res.status(404).json({ error: 'Producto no encontrado.' });
        }
        res.json(updatedProduct);
    } catch (err) {
        next(err);
    }
};

const deleteProduct = async (req, res, next) => {
    try {
        const deletedProduct = await Product.deleteProduct(req.params.id);
        if (!deletedProduct) {
            return res.status(404).json({ error: 'Producto no encontrado.' });
        }
        res.json(deletedProduct);
    } catch (err) {
        next(err);
    }
};

module.exports = {
    getProducts,
    getProductDetail,
    createProduct,
    updateProduct,
    deleteProduct,
};

---
---
 // api/src/controllers/user.controller.js

// src/controllers/user.controller.js

const User = require('../models/User');
const Address = require('../models/Address');
const bcrypt = require('bcrypt');
const SALT_ROUNDS = 10;

const getProfile = async (req, res, next) => {
    try {
        const userId = req.user.id;
        // Obtener datos del usuario
        const user = await User.findUserById(userId);
        if (!user) {
            return res.status(404).json({ error: 'Usuario no encontrado' });
        }
        // Obtener la dirección principal
        const mainAddress = await Address.getMainAddress(userId);
        return res.json({ user, mainAddress });
    } catch (err) {
        next(err);
    }
};

const updateProfile = async (req, res, next) => {
    try {
        const userId = req.user.id;
        // Extraer campos permitidos
        const { name, lastname, mail, password, phone, rut } = req.body;

        // Validar que el RUT no esté en uso por otro usuario
        const existingUserByRut = await User.findUserByRut(rut);
        if (existingUserByRut && existingUserByRut.id !== userId) {
            return res.status(400).json({ error: 'El RUT ya está en uso' });
        }

        // Validar que el correo no esté en uso por otro usuario
        const existingUserByMail = await User.findUserByMail(mail);
        if (existingUserByMail && existingUserByMail.id !== userId) {
            return res.status(400).json({ error: 'El correo ya está en uso' });
        }

        // Preparar el objeto de actualización
        const updatedData = { name, lastname, mail, phone, rut };

        // Si se envía password, hashearlo y agregarlo al objeto de actualización
        if (password && password.trim().length > 0) {
            updatedData.password = await bcrypt.hash(password, SALT_ROUNDS);
        }

        const updatedUser = await User.updateUser(userId, updatedData);
        res.json(updatedUser);
    } catch (err) {
        next(err);
    }
};

module.exports = {
    getProfile,
    updateProfile,
};

---
---
 // api/src/docs/routes/swaggerConfig.js

// src/docs/routes/swaggerConfig.js

const swaggerJSDoc = require('swagger-jsdoc');

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'La Pan Comido API',
      version: '1.0.0',
      description: 'API para el backend de La Pan Comido',
    },
    servers: [
      {
        url: 'http://localhost:3000/api',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
    },
    security: [
      {
        bearerAuth: [],
      },
    ],
  },
  // Se incluyen los archivos de rutas y los esquemas para que swagger-jsdoc los procese
  apis: ['./src/routes/*.js', './src/docs/routes/swaggerSchemas.js'],
};

const swaggerSpec = swaggerJSDoc(options);
module.exports = swaggerSpec;

---
---
 // api/src/docs/routes/swaggerSchemas.js

// src/docs/routes/swaggerSchemas.js

/**
 * @swagger
 * components:
 *   schemas:
 *     User:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *         name:
 *           type: string
 *         lastname:
 *           type: string
 *         mail:
 *           type: string
 *         rut:
 *           type: string
 *         phone:
 *           type: string
 *         created_at:
 *           type: string
 *           format: date-time
 *         updated_at:
 *           type: string
 *           format: date-time
 *       example:
 *         id: 1
 *         name: "Juan"
 *         lastname: "Pérez"
 *         mail: "juan@example.com"
 *         rut: "12.345.678-9"
 *         phone: "12345678"
 *         created_at: "2023-09-21T12:34:56Z"
 *         updated_at: "2023-09-21T12:34:56Z"
 *
 *     Product:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *         product:
 *           type: string
 *         ingredients:
 *           type: string
 *         price:
 *           type: number
 *         weight:
 *           type: number
 *         description:
 *           type: string
 *         nutrition:
 *           type: string
 *         available:
 *           type: boolean
 *         created_at:
 *           type: string
 *           format: date-time
 *         updated_at:
 *           type: string
 *           format: date-time
 *       example:
 *         id: 1
 *         product: "Pan Artesanal"
 *         ingredients: "Harina, agua, sal, levadura"
 *         price: 2.50
 *         weight: 0.5
 *         description: "Pan fresco hecho con ingredientes naturales"
 *         nutrition: "Alto en fibra y vitaminas"
 *         available: true
 *         created_at: "2023-09-21T12:34:56Z"
 *         updated_at: "2023-09-21T12:34:56Z"
 *
 *     Order:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *         id_user:
 *           type: integer
 *         id_address:
 *           type: integer
 *         order_delivery_date:
 *           type: string
 *           format: date
 *         status:
 *           type: string
 *         order_address:
 *           type: string
 *         order_city:
 *           type: string
 *         order_region:
 *           type: string
 *         order_postal_code:
 *           type: string
 *         order_phone:
 *           type: string
 *         created_at:
 *           type: string
 *           format: date-time
 *         updated_at:
 *           type: string
 *           format: date-time
 *       example:
 *         id: 1
 *         id_user: 1
 *         id_address: 2
 *         order_delivery_date: "2023-09-22"
 *         status: "En preparación"
 *         order_address: "Calle Falsa 123"
 *         order_city: "Ciudad"
 *         order_region: "Región"
 *         order_postal_code: "12345"
 *         order_phone: "987654321"
 *         created_at: "2023-09-21T12:34:56Z"
 *         updated_at: "2023-09-21T12:34:56Z"
 *
 *     Payment:
 *       type: object
 *       properties:
 *         paymentId:
 *           type: string
 *         status:
 *           type: string
 *         details:
 *           type: object
 *       example:
 *         paymentId: "PAY123456"
 *         status: "created"
 *         details: {}
  *     ImageUploadResponse:
 *       type: object
 *       properties:
 *         secure_url:
 *           type: string
 *         public_id:
 *           type: string
 *       example:
 *         secure_url: "https://res.cloudinary.com/tu-cuenta/image/upload/v1620000000/products/1234/imagen1.jpg"
 *         public_id: "products/1234/imagen1"
 *
 * /upload:
 *   post:
 *     security:
 *       - bearerAuth: []
 *     summary: Subir una imagen a Cloudinary para un producto.
 *     requestBody:
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               productId:
 *                 type: string
 *               image:
 *                 type: string
 *                 format: binary
 *     responses:
 *       200:
 *         description: Imagen subida correctamente.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/ImageUploadResponse'
 *
 *   delete:
 *     security:
 *       - bearerAuth: []
 *     summary: Eliminar una imagen de Cloudinary.
 *     requestBody:
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               public_id:
 *                 type: string
 *     responses:
 *       200:
 *         description: Imagen eliminada correctamente.
 */

---
---
 // api/src/helpers/cloudinaryHelper.js

// backend/src/helpers/cloudinaryHelper.js
const cloudinary = require('../../cloudinaryConfig'); // Ajusta la ruta si es necesario

/**
 * Sube un archivo a Cloudinary.
 * @param {Buffer} fileBuffer - El buffer del archivo.
 * @param {string} mimetype - El tipo MIME del archivo.
 * @param {string} folder - (Opcional) Carpeta destino en Cloudinary.
 * @returns {Promise<Object>} - Resultado de la subida (incluye secure_url y public_id).
 */
const uploadImage = (fileBuffer, mimetype, folder = 'productos') => {
    return new Promise((resolve, reject) => {
        const uploadStream = cloudinary.uploader.upload_stream(
            { folder },
            (error, result) => {
                if (error) {
                    reject(error);
                } else {
                    resolve(result);
                }
            }
        );
        uploadStream.end(fileBuffer);
    });
};

/**
 * Elimina una imagen de Cloudinary.
 * @param {string} publicId - El public_id de la imagen a eliminar.
 * @returns {Promise<Object>} - Resultado de la eliminación.
 */
const deleteImage = async (publicId) => {
    try {
        const result = await cloudinary.uploader.destroy(publicId);
        return result;
    } catch (error) {
        throw error;
    }
};

module.exports = { uploadImage, deleteImage };

---
---
 // api/src/middlewares/isAdmin.js

// src/middlewares/isAdmin.js
const isAdmin = (req, res, next) => {
    if (!req.user || !req.user.role) {
        return res.status(403).json({ error: "Acceso denegado: rol no especificado." });
    }
    if (req.user.role !== "admin") {
        return res.status(403).json({ error: "Acceso denegado: no eres administrador." });
    }
    next();
};

module.exports = isAdmin;

---
---
 // api/src/middlewares/validateCredentials.js

// src/middlewares/validateCredentials.js

module.exports = (req, res, next) => {
    const { mail, password } = req.body;
    if (!mail || !password) {
        return res.status(400).json({ error: 'Faltan credenciales: mail y/o password.' });
    }
    next();
};

---
---
 // api/src/middlewares/validateToken.js

// src/middlewares/validateToken.js

const jwt = require('jsonwebtoken');

module.exports.validateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    if (!authHeader) {
        return res.status(401).json({ error: 'Token no proporcionado.' });
    }
    const token = authHeader.split(' ')[1];
    if (!token) {
        return res.status(401).json({ error: 'Formato de token incorrecto.' });
    }
    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = decoded;
        next();
    } catch (err) {
        return res.status(401).json({ error: 'Token inválido.' });
    }
};

---
---
 // api/src/models/Address.js

// src/models/Address.js
const db = require('../config/db');
const schema = process.env.DB_SCHEMA;

const createAddress = async (addressData) => {
  const query = `
    INSERT INTO ${schema}.address (id_user, id_city, address, postal_code, main)
    VALUES ($1, $2, $3, $4, $5)
    RETURNING *
  `;
  const values = [
    addressData.id_user,
    addressData.id_city,
    addressData.address,
    addressData.postal_code || null,
    addressData.main || false,
  ];
  const { rows } = await db.query(query, values);
  return rows[0];
};

const getMainAddress = async (id_user) => {
  const query = `
    SELECT * FROM ${schema}.address
    WHERE id_user = $1 AND main = true
    LIMIT 1
  `;
  const { rows } = await db.query(query, [id_user]);
  return rows[0];
};

const getAddresses = async (id_user) => {
  const query = `
    SELECT * FROM ${schema}.address
    WHERE id_user = $1
    ORDER BY created_at DESC
  `;
  const { rows } = await db.query(query, [id_user]);
  return rows;
};

const getAddressById = async (id, id_user) => {
  const query = `
    SELECT * FROM ${schema}.address
    WHERE id = $1 AND id_user = $2
  `;
  const { rows } = await db.query(query, [id, id_user]);
  return rows[0];
};

const updateAddress = async (addressId, id_user, addressData) => {
  const query = `
    UPDATE ${schema}.address
    SET id_city = $1,
        address = $2,
        postal_code = $3,
        main = $4,
        updated_at = NOW()
    WHERE id = $5 AND id_user = $6
    RETURNING *
  `;
  const values = [
    addressData.id_city,
    addressData.address,
    addressData.postal_code || null,
    addressData.main || false,
    addressId,
    id_user,
  ];
  const { rows } = await db.query(query, values);
  return rows[0];
};

const deleteAddress = async (addressId, id_user) => {
  const query = `
    DELETE FROM ${schema}.address
    WHERE id = $1 AND id_user = $2
    RETURNING *
  `;
  const { rows } = await db.query(query, [addressId, id_user]);
  return rows[0];
};

// Función para desactivar la marca principal en todas las direcciones de un usuario,
// opcionalmente excluyendo una dirección (por ejemplo, la que se está actualizando)
const unsetMainForOtherAddresses = async (id_user, excludeAddressId = null) => {
  let query, values;
  if (excludeAddressId) {
    query = `
      UPDATE ${schema}.address
      SET main = false, updated_at = NOW()
      WHERE id_user = $1 AND id <> $2
    `;
    values = [id_user, excludeAddressId];
  } else {
    query = `
      UPDATE ${schema}.address
      SET main = false, updated_at = NOW()
      WHERE id_user = $1
    `;
    values = [id_user];
  }
  await db.query(query, values);
};

module.exports = {
  createAddress,
  getMainAddress,
  getAddresses,
  updateAddress,
  deleteAddress,
  unsetMainForOtherAddresses,
  getAddressById,
};

---
---
 // api/src/models/Auth.js

// src/models/Auth.js
const jwt = require('jsonwebtoken');

const generateToken = (user) => {
    // Convertir role_id a un string representativo, por ejemplo:
    const role = user.role_id === 2 || user.role_id === 3 ? "admin" : "customer";
    const payload = { id: user.id, email: user.mail, role };
    return jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '1h' });
};

const verifyToken = (token) => {
    return jwt.verify(token, process.env.JWT_SECRET);
};

module.exports = {
    generateToken,
    verifyToken,
};

---
---
 // api/src/models/Favorites.js

// src/models/Favorites.js

const db = require('../config/db');
const schema = process.env.DB_SCHEMA;

const addFavorite = async (userId, productId) => {
  const query = `
    INSERT INTO ${schema}.favorites (id_user, id_product)
    VALUES ($1, $2)
    ON CONFLICT (id_user, id_product) DO NOTHING
    RETURNING *
  `;
  const { rows } = await db.query(query, [userId, productId]);
  return rows[0];
};

const removeFavorite = async (userId, productId) => {
  const query = `
    DELETE FROM ${schema}.favorites
    WHERE id_user = $1 AND id_product = $2
    RETURNING *
  `;
  const { rows } = await db.query(query, [userId, productId]);
  return rows[0];
};

const getFavorites = async (userId) => {
  const query = `
    SELECT p.*
    FROM ${schema}.favorites f
    JOIN ${schema}.products p ON f.id_product = p.id
    WHERE f.id_user = $1 AND p.available = true
  `;
  const { rows } = await db.query(query, [userId]);
  return rows;
};

module.exports = {
  addFavorite,
  removeFavorite,
  getFavorites,
};


---
---
 // api/src/models/Product.js

const db = require('../config/db');
const schema = process.env.DB_SCHEMA;

const getAllProducts = async () => {
  const query = `
    SELECT id, product, ingredients, price, weight, description, nutrition, available, created_at, updated_at
    FROM ${schema}.products
  `;
  const { rows } = await db.query(query);
  return rows;
};

const getProductById = async (id) => {
  const query = `
    SELECT id, product, ingredients, price, weight, description, nutrition, available, created_at, updated_at
    FROM ${schema}.products
    WHERE id = $1
  `;
  const { rows } = await db.query(query, [id]);
  return rows[0];
};

const createProduct = async (productData) => {
  const query = `
    INSERT INTO ${schema}.products (product, ingredients, price, weight, description, nutrition, available)
    VALUES ($1, $2, $3, $4, $5, $6, $7)
    RETURNING *
  `;
  const values = [
    productData.product,
    productData.ingredients || null,
    productData.price,
    productData.weight || null,
    productData.description || null,
    productData.nutrition || null,
    productData.available !== undefined ? productData.available : false // default false
  ];
  const { rows } = await db.query(query, values);
  return rows[0];
};

const createStock = async (productId, stockValue) => {
  const query = `
    INSERT INTO ${schema}.stock (id_product, stock)
    VALUES ($1, $2)
    RETURNING *
  `;
  const values = [productId, stockValue];
  const { rows } = await db.query(query, values);
  return rows[0];
};

const updateProduct = async (id, productData) => {
  const query = `
    UPDATE ${schema}.products
    SET product = $1,
        ingredients = $2,
        price = $3,
        weight = $4,
        description = $5,
        nutrition = $6,
        available = $7,
        updated_at = NOW()
    WHERE id = $8
    RETURNING *
  `;
  const values = [
    productData.product,
    productData.ingredients || null,
    productData.price,
    productData.weight || null,
    productData.description || null,
    productData.nutrition || null,
    productData.available,
    id,
  ];
  const { rows } = await db.query(query, values);
  return rows[0];
};

const deleteProduct = async (id) => {
  const query = `DELETE FROM ${schema}.products WHERE id = $1 RETURNING *`;
  const { rows } = await db.query(query, [id]);
  return rows[0];
};

module.exports = {
  getAllProducts,
  getProductById,
  createProduct,
  createStock,
  updateProduct,
  deleteProduct,
};
---
---
 // api/src/models/User.js

// src/models/User.js

const db = require('../config/db');
const bcrypt = require('bcrypt');
const SALT_ROUNDS = 10;
const schema = process.env.DB_SCHEMA;

const createUser = async (userData) => {
    if (!userData.password) {
        throw new Error("Password is required");
    }
    // Hashea la contraseña
    const hashedPassword = await bcrypt.hash(userData.password, SALT_ROUNDS);
    // console.log("Contraseña original:", userData.password);
    // console.log("Contraseña hasheada:", hashedPassword); // Esto te ayudará a verificar que el hash se está generando

    const query = `
    INSERT INTO ${schema}.users (name, lastname, mail, password)
    VALUES ($1, $2, $3, $4)
    RETURNING id, name, lastname, mail, created_at, updated_at
  `;
    const values = [
        userData.name,
        userData.lastname,
        userData.mail,
        hashedPassword  // Se usa la contraseña hasheada
    ];
    const { rows } = await db.query(query, values);
    return rows[0];
};

const updateUser = async (id, userData) => {
    const query = `
      UPDATE ${schema}.users
      SET name = $1,
          lastname = $2,
          mail = $3,
          password = COALESCE($4, password),
          phone = $5,
          rut = $6,
          updated_at = NOW()
      WHERE id = $7
      RETURNING id, name, lastname, mail, phone, rut, created_at, updated_at
    `;
    const values = [
        userData.name,
        userData.lastname,
        userData.mail,
        userData.password || null, // si no se envía password, se mantiene el valor anterior
        userData.phone,
        userData.rut,
        id,
    ];
    const { rows } = await db.query(query, values);
    return rows[0];
};

const findUserByRut = async (rut) => {
    const query = `SELECT * FROM ${schema}.users WHERE rut = $1`;
    const { rows } = await db.query(query, [rut]);
    return rows[0];
};

const findUserByMail = async (mail) => {
    const query = `SELECT * FROM ${schema}.users WHERE mail = $1`;
    const { rows } = await db.query(query, [mail]);
    return rows[0];
};

const findUserById = async (id) => {
    const query = `
      SELECT id, name, lastname, mail, phone, rut, created_at, updated_at
      FROM ${schema}.users
      WHERE id = $1
    `;
    const { rows } = await db.query(query, [id]);
    return rows[0];
};


module.exports = {
    createUser,
    findUserByMail,
    findUserById,
    updateUser,
    findUserByRut,
};

---
---
 // api/src/routes/address.routes.js

// src/routes/address.routes.js

/**
 * @swagger
 * tags:
 *   name: Address
 *   description: Endpoints para la gestión de direcciones
 *
 * /address:
 *   post:
 *     summary: Crear una nueva dirección
 *     tags: [Address]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Objeto con los datos de la dirección a crear
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id_city:
 *                 type: integer
 *               address:
 *                 type: string
 *               postal_code:
 *                 type: string
 *               main:
 *                 type: boolean
 *             example:
 *               id_city: 1
 *               address: "Calle Falsa 123"
 *               postal_code: "12345"
 *               main: true
 *     responses:
 *       201:
 *         description: Dirección creada correctamente.
 *       401:
 *         description: No autenticado.
 *
 *   get:
 *     summary: Listar direcciones del usuario
 *     tags: [Address]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lista de direcciones.
 *
 * /address/{id}:
 *   put:
 *     summary: Actualizar una dirección existente
 *     tags: [Address]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la dirección a actualizar.
 *     requestBody:
 *       description: Datos actualizados de la dirección
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id_city:
 *                 type: integer
 *               address:
 *                 type: string
 *               postal_code:
 *                 type: string
 *               main:
 *                 type: boolean
 *             example:
 *               id_city: 2
 *               address: "Calle Nueva 456"
 *               postal_code: "67890"
 *               main: false
 *     responses:
 *       200:
 *         description: Dirección actualizada correctamente.
 *       404:
 *         description: Dirección no encontrada.
 *
 *   delete:
 *     summary: Eliminar una dirección
 *     tags: [Address]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la dirección a eliminar.
 *     responses:
 *       200:
 *         description: Dirección eliminada.
 *       404:
 *         description: Dirección no encontrada.
 */

const express = require('express');
const router = express.Router();
const addressController = require('../controllers/address.controller');
const { validateToken } = require('../middlewares/validateToken');

// Crear dirección
router.post('/', validateToken, addressController.createAddress);

// Listar direcciones
router.get('/', validateToken, addressController.getAddresses);

// Actualizar dirección
router.put('/:id', validateToken, addressController.updateAddress);

// Eliminar dirección
router.delete('/:id', validateToken, addressController.deleteAddress);

module.exports = router;

---
---
 // api/src/routes/admin.routes.js

// src/routes/admin.routes.js

/**
 * @swagger
 * tags:
 *   - name: Admin
 *     description: Endpoints para administración de la aplicación
 *
 * /admin/dashboard:
 *   get:
 *     summary: Obtener el resumen de la tienda (ventas, stock y pedidos del mes)
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Resumen del dashboard.
 *       401:
 *         description: Token inválido o no proporcionado.
 *
 * /admin/orders/pending:
 *   get:
 *     summary: Listar los pedidos pendientes (no finalizados)
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lista de pedidos pendientes.
 *
 * /admin/orders/historical:
 *   get:
 *     summary: Listar los pedidos históricos (finalizados)
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lista de pedidos históricos.
 *
 * /admin/users:
 *   get:
 *     summary: Listar usuarios registrados
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lista de usuarios.
 *
 * /admin/users/{userId}/role:
 *   put:
 *     summary: Cambiar el rol de un usuario
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID del usuario.
 *     requestBody:
 *       description: Nuevo rol del usuario ("customer", "admin" o "developer")
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               role:
 *                 type: string
 *             example:
 *               role: "admin"
 *     responses:
 *       200:
 *         description: Rol actualizado.
 *       404:
 *         description: Usuario no encontrado.
 *
 * /admin/users/{userId}/disable:
 *   put:
 *     summary: Desactivar un usuario
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID del usuario a desactivar.
 *     responses:
 *       200:
 *         description: Usuario desactivado.
 *       404:
 *         description: Usuario no encontrado.
 *
 * /admin/users/{userId}/enable:
 *   put:
 *     summary: Habilitar (reactivar) un usuario
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID del usuario a habilitar.
 *     responses:
 *       200:
 *         description: Usuario habilitado.
 *       404:
 *         description: Usuario no encontrado.
 *
 * /admin/users/{userId}:
 *   delete:
 *     summary: Eliminar un usuario
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userId
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID del usuario a eliminar.
 *     responses:
 *       200:
 *         description: Usuario eliminado.
 *       404:
 *         description: Usuario no encontrado.
 *
 * /admin/products:
 *   post:
 *     summary: Crear un nuevo producto
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Datos del producto y stock inicial
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product:
 *                 type: string
 *               price:
 *                 type: number
 *               ingredients:
 *                 type: string
 *               weight:
 *                 type: number
 *               nutrition:
 *                 type: string
 *               available:
 *                 type: boolean
 *               stock:
 *                 type: number
 *             example:
 *               product: "Pan Artesanal"
 *               price: 250
 *               ingredients: "Harina, agua, levadura"
 *               weight: 0.5
 *               nutrition: "Alto en fibra"
 *               available: true
 *               stock: 100
 *     responses:
 *       201:
 *         description: Producto creado.
 *   get:
 *     summary: Listar productos para administración (con imagen y stock)
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lista de productos.
 *   delete:
 *     summary: Eliminación masiva de productos
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Arreglo con los IDs de los productos a eliminar
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               productIds:
 *                 type: array
 *                 items:
 *                   type: integer
 *             example:
 *               productIds: [1, 2, 3]
 *     responses:
 *       200:
 *         description: Productos eliminados.
 *
 * /admin/products/{id}:
 *   put:
 *     summary: Actualizar los datos de un producto (incluye categorías)
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID del producto a actualizar.
 *     requestBody:
 *       description: Datos del producto a actualizar
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product:
 *                 type: string
 *               price:
 *                 type: number
 *               ingredients:
 *                 type: string
 *               weight:
 *                 type: number
 *               nutrition:
 *                 type: string
 *               available:
 *                 type: boolean
 *               categories:
 *                 type: array
 *                 items:
 *                   type: string
 *             example:
 *               product: "Pan Integral"
 *               price: 300
 *               ingredients: "Harina integral, agua, levadura"
 *               weight: 0.5
 *               nutrition: "Rico en fibra"
 *               available: true
 *               categories: ["Integral", "Saludable"]
 *     responses:
 *       200:
 *         description: Producto actualizado.
 *
 * /admin/products/{id}/stock:
 *   put:
 *     summary: Actualizar el stock de un producto
 *     tags: [Admin]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID del producto.
 *     requestBody:
 *       description: Nuevo stock del producto
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               stock:
 *                 type: number
 *             example:
 *               stock: 150
 *     responses:
 *       200:
 *         description: Stock actualizado.
 */

const express = require('express');
const router = express.Router();
const { validateToken } = require('../middlewares/validateToken');
const isAdmin = require('../middlewares/isAdmin');

// Rutas existentes para dashboard, pedidos y usuarios...
const adminDashboardController = require('../controllers/adminDashboard.controller');
const orderController = require('../controllers/order.controller');
const adminUsersController = require('../controllers/adminUsers.controller');

// Agregamos las rutas para la gestión de productos en admin
const adminProductsController = require('../controllers/adminProducts.controller');

// Dashboard de administración
router.get('/dashboard', validateToken, isAdmin, adminDashboardController.getDashboardSummary);

// Pedidos pendientes e históricos para admin
router.get('/orders/pending', validateToken, isAdmin, orderController.getAdminPendingOrders);
router.get('/orders/historical', validateToken, isAdmin, orderController.getAdminHistoricalOrders);

// Gestión de usuarios para admin
router.get('/users', validateToken, isAdmin, adminUsersController.listUsers);
router.put('/users/:userId/role', validateToken, isAdmin, adminUsersController.updateUserRole);
router.put('/users/:userId/disable', validateToken, isAdmin, adminUsersController.disableUser);
router.put('/users/:userId/enable', validateToken, isAdmin, adminUsersController.enableUser);
router.delete('/users/:userId', validateToken, isAdmin, adminUsersController.deleteUser);

// Rutas de productos para admin
router.post('/products', validateToken, isAdmin, adminProductsController.createProduct);
router.put('/products/:id', validateToken, isAdmin, adminProductsController.updateProductDetails);
router.put('/products/:id/stock', validateToken, isAdmin, adminProductsController.updateStock);
router.delete('/products', validateToken, isAdmin, adminProductsController.deleteMultipleProducts);
router.get('/products', validateToken, isAdmin, adminProductsController.getAdminProducts);

module.exports = router;

---
---
 // api/src/routes/auth.routes.js

/**
 * @swagger
 * tags:
 *   - name: Auth
 *     description: Endpoints de autenticación y reseteo de contraseña
 *
 * /auth/register:
 *   post:
 *     summary: Registrar un nuevo usuario
 *     tags: [Auth]
 *     requestBody:
 *       description: Datos del usuario a registrar
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               lastname:
 *                 type: string
 *               mail:
 *                 type: string
 *               password:
 *                 type: string
 *             example:
 *               name: "Juan"
 *               lastname: "Pérez"
 *               mail: "juan@example.com"
 *               password: "secret123"
 *     responses:
 *       201:
 *         description: Usuario registrado correctamente.
 *       400:
 *         description: Error en los campos requeridos.
 *
 * /auth/login:
 *   post:
 *     summary: Iniciar sesión
 *     tags: [Auth]
 *     requestBody:
 *       description: Credenciales del usuario
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               mail:
 *                 type: string
 *               password:
 *                 type: string
 *             example:
 *               mail: "juan@example.com"
 *               password: "secret123"
 *     responses:
 *       200:
 *         description: Inicio de sesión exitoso, retorna un token JWT.
 *       401:
 *         description: Credenciales inválidas.
 *
 * /auth/test:
 *   get:
 *     summary: Ruta de prueba para autenticación
 *     tags: [Auth]
 *     responses:
 *       200:
 *         description: Ruta de prueba funcionando.
 *
 * /auth/reset-password/request:
 *   post:
 *     summary: Solicitar reseteo de contraseña
 *     description: Genera y envía un código de 6 dígitos a la cuenta de correo del usuario. El código es válido por 5 minutos.
 *     tags: [Auth]
 *     requestBody:
 *       description: Email del usuario para el reseteo.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *             example:
 *               email: "usuario@example.com"
 *     responses:
 *       200:
 *         description: Código enviado.
 *       404:
 *         description: Usuario no encontrado.
 *
 * /auth/reset-password/confirm:
 *   post:
 *     summary: Confirmar reseteo de contraseña
 *     description: Valida el código enviado y permite cambiar la contraseña.
 *     tags: [Auth]
 *     requestBody:
 *       description: Se requiere enviar el email, el código recibido y la nueva contraseña.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *               resetCode:
 *                 type: string
 *               newPassword:
 *                 type: string
 *             example:
 *               email: "usuario@example.com"
 *               resetCode: "123456"
 *               newPassword: "nuevaContraseña123"
 *     responses:
 *       200:
 *         description: Contraseña actualizada exitosamente.
 *       400:
 *         description: Código inválido o expirado.
 */

const express = require('express');
const router = express.Router();
const authController = require('../controllers/auth.controller');

// Endpoint para registrar usuario
router.post('/register', authController.register);
// Endpoint para login
router.post('/login', authController.login);
// Ruta de prueba
router.get('/test', (req, res) => res.json({ message: 'Ruta de prueba auth funcionando' }));
// Rutas para reseteo de contraseña
router.post('/reset-password/request', authController.resetPasswordRequest);
router.post('/reset-password/confirm', authController.resetPasswordConfirm);

module.exports = router;

---
---
 // api/src/routes/categories.routes.js

// src/routes/categories.routes.js
const express = require('express');
const router = express.Router();
const { getCategories } = require('../controllers/categories.controller');

router.get('/', getCategories);

module.exports = router;

---
---
 // api/src/routes/favorites.routes.js

// src/routes/favorites.routes.js

/**
 * @swagger
 * tags:
 *   name: Favorites
 *   description: Endpoints para gestionar los favoritos de un usuario
 *
 * /favorites:
 *   post:
 *     summary: Agregar un producto a favoritos
 *     tags: [Favorites]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Objeto que contiene el productId a agregar
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               productId:
 *                 type: integer
 *             example:
 *               productId: 1
 *     responses:
 *       201:
 *         description: Producto agregado a favoritos.
 *
 *   delete:
 *     summary: Remover un producto de favoritos
 *     tags: [Favorites]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Objeto que contiene el productId a remover
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               productId:
 *                 type: integer
 *             example:
 *               productId: 1
 *     responses:
 *       200:
 *         description: Favorito removido.
 *
 *   get:
 *     summary: Listar los productos favoritos del usuario
 *     tags: [Favorites]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lista de productos favoritos.
 */

const express = require('express');
const router = express.Router();
const favoritesController = require('../controllers/favorites.controller');
const { validateToken } = require('../middlewares/validateToken');

router.post('/', validateToken, favoritesController.addFavorite);
router.delete('/', validateToken, favoritesController.removeFavorite);
router.get('/', validateToken, favoritesController.listFavorites);

module.exports = router;


---
---
 // api/src/routes/gateways.routes.js

// src/routes/gateways.routes.js

/**
 * @swagger
 * tags:
 *   name: Gateways
 *   description: Endpoints para gestionar pagos
 *
 * /gateways/payments:
 *   post:
 *     summary: Crear un pago
 *     tags: [Gateways]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Datos del pago
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               amount:
 *                 type: number
 *               currency:
 *                 type: string
 *             example:
 *               amount: 500
 *               currency: "USD"
 *     responses:
 *       201:
 *         description: Pago creado exitosamente.
 */

const express = require('express');
const router = express.Router();
const gatewaysController = require('../controllers/gateways.controller');
const { validateToken } = require('../middlewares/validateToken');

router.post('/payments', validateToken, gatewaysController.createPayment);

module.exports = router;

---
---
 // api/src/routes/order.routes.js

// src/routes/order.routes.js

/**
 * @swagger
 * tags:
 *   name: Orders
 *   description: Endpoints para gestionar órdenes de compra
 *
 * /orders:
 *   post:
 *     summary: Crear una nueva orden
 *     tags: [Orders]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Datos para crear la orden
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id_address:
 *                 type: integer
 *               order_delivery_date:
 *                 type: string
 *                 format: date
 *               order_address:
 *                 type: string
 *               order_city:
 *                 type: string
 *               order_region:
 *                 type: string
 *               order_postal_code:
 *                 type: string
 *               order_phone:
 *                 type: string
 *             example:
 *               id_address: 2
 *               order_delivery_date: "2025-02-15"
 *               order_address: "Calle Falsa 123"
 *               order_city: "Ciudad"
 *               order_region: "Región"
 *               order_postal_code: "12345"
 *               order_phone: "987654321"
 *     responses:
 *       201:
 *         description: Orden creada.
 *
 *   get:
 *     summary: Listar órdenes del usuario
 *     tags: [Orders]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lista de órdenes.
 *
 * /orders/detailed:
 *   get:
 *     summary: Obtener órdenes con detalle (incluye productos y totales)
 *     tags: [Orders]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Órdenes detalladas.
 *
 * /orders/{id}:
 *   get:
 *     summary: Obtener una orden por ID
 *     tags: [Orders]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID de la orden a obtener.
 *     responses:
 *       200:
 *         description: Detalle de la orden.
 *       404:
 *         description: Orden no encontrada.
 *
 * /orders/checkout:
 *   post:
 *     summary: Confirmar compra (checkout)
 *     tags: [Orders]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Datos para procesar la compra, incluyendo items
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id_address:
 *                 type: integer
 *               order_delivery_date:
 *                 type: string
 *                 format: date
 *               order_address:
 *                 type: string
 *               order_city:
 *                 type: string
 *               order_region:
 *                 type: string
 *               order_postal_code:
 *                 type: string
 *               order_phone:
 *                 type: string
 *               items:
 *                 type: array
 *                 items:
 *                   type: object
 *                   properties:
 *                     productId:
 *                       type: integer
 *                     units:
 *                       type: integer
 *                     unit_price:
 *                       type: number
 *             example:
 *               id_address: 2
 *               order_delivery_date: "2025-02-15"
 *               order_address: "Calle Falsa 123"
 *               order_city: "Ciudad"
 *               order_region: "Región"
 *               order_postal_code: "12345"
 *               order_phone: "987654321"
 *               items:
 *                 - productId: 1
 *                   units: 2
 *                   unit_price: 100
 *                 - productId: 3
 *                   units: 1
 *                   unit_price: 250
 *     responses:
 *       201:
 *         description: Orden procesada exitosamente.
 *       400:
 *         description: Error en el procesamiento de la orden.
 */

const express = require('express');
const router = express.Router();
const orderController = require('../controllers/order.controller');
const { validateToken } = require('../middlewares/validateToken');

// Endpoint para obtener las órdenes detalladas
router.get('/detailed', validateToken, orderController.getDetailedOrders);

// Luego la ruta con parámetro para obtener una orden por id
router.get('/:id', validateToken, orderController.getOrderById);

// Otros endpoints de órdenes
router.post('/', validateToken, orderController.createOrder);
router.get('/', validateToken, orderController.getOrders);

// Nuevo endpoint para confirmar la compra (checkout)
router.post('/checkout', validateToken, orderController.confirmPurchase);

module.exports = router;

---
---
 // api/src/routes/product.routes.js

// src/routes/product.routes.js

/**
 * @swagger
 * tags:
 *   name: Products
 *   description: Endpoints para el catálogo de productos
 *
 * /products:
 *   get:
 *     summary: Listar productos públicos
 *     tags: [Products]
 *     parameters:
 *       - in: query
 *         name: category
 *         schema:
 *           type: string
 *         description: Filtro por categoría
 *       - in: query
 *         name: search
 *         schema:
 *           type: string
 *         description: Término de búsqueda (nombre o descripción)
 *     responses:
 *       200:
 *         description: Lista de productos disponibles.
 *
 * /products/{id}:
 *   get:
 *     summary: Obtener detalle de un producto
 *     tags: [Products]
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID del producto.
 *     responses:
 *       200:
 *         description: Detalle del producto, incluyendo imágenes, categorías y stock.
 *       404:
 *         description: Producto no encontrado.
 */

const express = require('express');
const router = express.Router();
const productController = require('../controllers/product.controller'); // Funciones públicas

// Rutas públicas
router.get('/', productController.getProducts);
router.get('/:id', productController.getProductDetail);

module.exports = router;

---
---
 // api/src/routes/productImages.routes.js

// src/routes/productImages.routes.js

/**
 * @swagger
 * tags:
 *   name: Product Images
 *   description: Endpoints para la gestión de imágenes de productos
 *
 * /product-images/save-images:
 *   post:
 *     summary: Guardar las URLs de las imágenes en la base de datos
 *     tags: [Product Images]
 *     requestBody:
 *       description: Objeto que contiene el productId y un arreglo de imágenes (con su URL)
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               productId:
 *                 type: integer
 *               images:
 *                 type: array
 *                 items:
 *                   type: object
 *                   properties:
 *                     url:
 *                       type: string
 *             example:
 *               productId: 1
 *               images:
 *                 - url: "https://res.cloudinary.com/tu-cloud-name/image/upload/v1234567890/productos/1/imagen1.jpg"
 *                 - url: "https://res.cloudinary.com/tu-cloud-name/image/upload/v1234567890/productos/1/imagen2.jpg"
 *     responses:
 *       200:
 *         description: Imágenes guardadas en la base de datos.
 *       400:
 *         description: Datos inválidos.
 */

// src/routes/productImages.routes.js

const express = require('express');
const router = express.Router();
const db = require('../config/db');
const schema = process.env.DB_SCHEMA;
const { validateToken } = require('../middlewares/validateToken');
const isAdmin = require('../middlewares/isAdmin');

router.post('/save-images', validateToken, isAdmin, async (req, res, next) => {
    try {
        // Se espera recibir: { productId: number, images: [{ url or secure_url, public_id }, ...] }
        const { productId, images } = req.body;
        if (!productId || !Array.isArray(images) || images.length === 0) {
            return res.status(400).json({ error: "Se requiere productId y un arreglo de imágenes" });
        }

        // Filtrar solo imágenes válidas (deben tener URL y public_id)
        const validImages = images.filter(img => img && (img.url || img.secure_url) && img.public_id);
        if (validImages.length === 0) {
            return res.status(400).json({ error: "No hay imágenes válidas para guardar" });
        }

        const insertedImages = [];
        for (const img of validImages) {
            const imageUrl = img.url || img.secure_url;
            const query = `
        INSERT INTO ${schema}.product_img (id_product, url_img, cloudinary_public_id)
        VALUES ($1, $2, $3)
        RETURNING *
      `;
            const { rows } = await db.query(query, [productId, imageUrl, img.public_id]);
            insertedImages.push(rows[0]);
        }
        res.status(200).json({ message: "Imágenes guardadas correctamente", images: insertedImages });
    } catch (error) {
        next(error);
    }
});

module.exports = router;

---
---
 // api/src/routes/routes.js

// src/routes/routes.js



const express = require('express');
const router = express.Router();

const authRoutes = require('./auth.routes');
const gatewaysRoutes = require('./gateways.routes');
const productRoutes = require('./product.routes');
const orderRoutes = require('./order.routes');
const addressRoutes = require('./address.routes');
const favoritesRoutes = require('./favorites.routes');
const userRoutes = require('./user.routes');
const adminRoutes = require('./admin.routes');
const productImagesRoutes = require('./productImages.routes');
const uploadRoute = require('./uploadRoute');
const categoriesRoutes = require('./categories.routes');

router.use('/auth', authRoutes);
router.use('/gateways', gatewaysRoutes);
router.use('/products', productRoutes);
router.use('/orders', orderRoutes);
router.use('/address', addressRoutes);
router.use('/favorites', favoritesRoutes);
router.use('/profile', userRoutes);
router.use('/admin', adminRoutes);
router.use('/product-images', productImagesRoutes);
router.use('/upload', uploadRoute);
router.use('/categories', categoriesRoutes);

// Ruta de test global opcional:
router.get('/test', (req, res) => res.json({ message: 'Ruta de test global funcionando' }));

module.exports = router;

---
---
 // api/src/routes/uploadRoute.js

// src/routes/uploadRoute.js

/**
 * @swagger
 * tags:
 *   name: Upload
 *   description: Endpoint para subir imágenes a Cloudinary
 *
 * /upload:
 *   post:
 *     summary: Subir imágenes de un producto a Cloudinary
 *     tags: [Upload]
 *     requestBody:
 *       description: Se requiere enviar un productId y hasta 4 archivos de imagen
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               productId:
 *                 type: string
 *               images:
 *                 type: array
 *                 items:
 *                   type: string
 *                   format: binary
 *             example:
 *               productId: "1"
 *     responses:
 *       200:
 *         description: Imágenes subidas correctamente, retorna las URLs y public_ids.
 *       500:
 *         description: Error al subir imágenes.
 */

// src/routes/uploadRoute.js
const express = require('express');
const multer = require('multer');
const { uploadImage, deleteImage } = require('../helpers/cloudinaryHelper');
const { validateToken } = require('../middlewares/validateToken');
const isAdmin = require('../middlewares/isAdmin');

const router = express.Router();

// Configuración de multer en memoria
const storage = multer.memoryStorage();
const upload = multer({
    storage,
    limits: { files: 4 } // Limita a 4 archivos
});

// Endpoint para subir imágenes a Cloudinary, exclusivo para Admin
router.post('/', validateToken, isAdmin, upload.single('image'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({ error: "No se ha enviado ningún archivo." });
        }
        // req.file contiene buffer y mimetype
        const result = await uploadImage(req.file.buffer, req.file.mimetype, `productos/${req.body.productId || ''}`);
        // Devuelve la URL y el public_id para usar en la carga del producto
        res.status(200).json({ secure_url: result.secure_url, public_id: result.public_id });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: "Error al subir imagen", error: error.message });
    }
});

// Endpoint para eliminar una imagen de Cloudinary, exclusivo para Admin
router.delete('/', validateToken, isAdmin, async (req, res) => {
    try {
        const { public_id } = req.body;
        if (!public_id) {
            return res.status(400).json({ error: "Se requiere el public_id de la imagen a eliminar." });
        }
        const result = await deleteImage(public_id);
        res.status(200).json({ message: "Imagen eliminada", result });
    } catch (error) {
        res.status(500).json({ message: "Error al eliminar imagen", error: error.message });
    }
});

module.exports = router;


---
---
 // api/src/routes/user.routes.js

// src/routes/user.routes.js

/**
 * @swagger
 * tags:
 *   name: User
 *   description: Endpoints para gestionar el perfil del usuario
 *
 * /profile:
 *   get:
 *     summary: Obtener los datos del perfil del usuario y su dirección principal
 *     tags: [User]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Datos del usuario y dirección principal.
 *       404:
 *         description: Usuario no encontrado.
 *
 *   put:
 *     summary: Actualizar los datos personales del usuario
 *     tags: [User]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Datos a actualizar (name, lastname, mail, password, phone, rut)
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *               lastname:
 *                 type: string
 *               mail:
 *                 type: string
 *               password:
 *                 type: string
 *               phone:
 *                 type: string
 *               rut:
 *                 type: string
 *             example:
 *               name: "Juan"
 *               lastname: "Pérez"
 *               mail: "juan@example.com"
 *               password: "nuevoPassword123"
 *               phone: "12345678"
 *               rut: "12.345.678-9"
 *     responses:
 *       200:
 *         description: Perfil actualizado correctamente.
 *       400:
 *         description: Error en la validación (ej. correo o RUT duplicado).
 */

const express = require('express');
const router = express.Router();
const userController = require('../controllers/user.controller');
const { validateToken } = require('../middlewares/validateToken');

// Endpoint para obtener el perfil (MiCuenta)
router.get('/', validateToken, userController.getProfile);

// Endpoint para actualizar los datos personales (MisDatos)
router.put('/', validateToken, userController.updateProfile);

module.exports = router;

---
---
 // api/src/server.js

// src/server.js
const uploadRoute = require('./routes/uploadRoute.js');
const express = require('express');
const cors = require('cors');
const morgan = require('morgan');
const routes = require('./routes/routes.js');
const swaggerUi = require('swagger-ui-express');
const swaggerSpec = require('./docs/routes/swaggerConfig.js');


const app = express();

// Middlewares
app.use(cors());
app.use(morgan('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Middleware de debug: muestra la URL y el método de cada petición
app.use((req, res, next) => {
    console.log(`DEBUG: Received ${req.method} request for ${req.originalUrl}`);
    next();
});

// Rutas de la API
app.use('/api', routes);

// Endpoint para la documentación Swagger
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Middleware 404 para rutas no definidas
app.use((req, res, next) => {
    res.status(404).json({ error: 'Ruta no encontrada' });
});

// Middleware de manejo de errores
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'Algo salió mal en el servidor.' });
});

// // Fragmento para debug
// app.use((req, res, next) => {
//     console.log(`Petición recibida: ${req.method} ${req.originalUrl}`);
//     next();
// });

module.exports = app;

---
---
 // api/src/services/paymentService.js

// src/services/paymentService.js
module.exports.createPayment = async (paymentData) => {
    // Simula la creación de un pago.
    // paymentData podría incluir: amount, currency, userId, etc.
    return {
        paymentId: 'PAY123456',
        status: 'created',
        details: paymentData,
    };
};

---
---
 // api/tests/server.test.js

// tests/auth.test.js
const request = require('supertest');
const app = require('../src/server');

describe('POST /api/auth/register', () => {
    it('debería registrar un usuario nuevo', async () => {
        const newUser = {
            name: "Test",
            lastname: "User",
            mail: "testuser@example.com",
            password: "password123"
        };
        const res = await request(app)
            .post('/api/auth/register')
            .send(newUser);
        expect(res.statusCode).toEqual(201);
        expect(res.body).toHaveProperty("id");
    });

    it('debería retornar error si faltan campos obligatorios', async () => {
        const incompleteUser = {
            name: "Test",
            mail: "testuser@example.com",
            password: "password123"
        };
        const res = await request(app)
            .post('/api/auth/register')
            .send(incompleteUser);
        expect(res.statusCode).toEqual(400);
        expect(res.body).toHaveProperty("error");
    });
});

---
---
 // eslint.config.js

import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

---
---
 // index.html

<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/favicon.png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title> Pan Comido</title>
</head>

<body>
  <div id="root"></div>
  <script type="module" src="/src/main.jsx"></script>
</body>

</html>
---
---
 // package.json

{
  "name": "pancomido",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "vite",
    "dev": "vite --open",
    "build": "vite build",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@stripe/react-stripe-js": "^3.1.1",
    "@stripe/stripe-js": "^5.6.0",
    "@tailwindcss/vite": "^4.0.1",
    "antd": "^5.23.3",
    "crypto-js": "^4.2.0",
    "dotenv": "^16.4.7",
    "framer-motion": "^12.0.6",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-icons": "^5.4.0",
    "react-router-dom": "^7.1.3",
    "react-toastify": "^11.0.3",
    "swiper": "^11.2.2",
    "tailwindcss": "^4.0.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.17.0",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "vite": "^6.0.5"
  }
}

---
---
 // printFiles.js

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

// Directorio raíz (la carpeta actual donde se ejecuta el script)
const rootDir = process.cwd();
const rootName = path.basename(rootDir);

// Nombre del archivo de salida (por ejemplo, "miProyecto.txt" si la carpeta se llama "miProyecto")
const outputFile = path.join(rootDir, `${rootName}.txt`);

// Ejecutamos el comando "tree /f" y capturamos su salida
let treeOutput = '';
try {
  treeOutput = execSync('tree /f', { encoding: 'utf8' });
} catch (error) {
  console.error('Error ejecutando el comando tree /f:', error);
  treeOutput = 'tree /f'; // Fallback en caso de error
}

// Iniciamos el contenido con la salida real del comando "tree /f"
let outputContent = treeOutput + '\n\n';

/**
 * Función que recorre recursivamente una carpeta y agrega el contenido
 * de cada archivo encontrado a la variable outputContent.
 * @param {string} dir - Ruta del directorio a recorrer.
 */
function traverseDirectory(dir) {
  const items = fs.readdirSync(dir);

  items.forEach((item) => {
    // Omitir las carpetas: node_modules, public, assets y dist
    if (['assets', 'node_modules', 'public', 'dist', '.git'].includes(item)) {
      return;
    }

    const fullPath = path.join(dir, item);
    const stats = fs.statSync(fullPath);

    if (stats.isDirectory()) {
      // Recorrer la carpeta recursivamente
      traverseDirectory(fullPath);
    } else if (stats.isFile()) {
      // Evitar procesar el archivo de salida y package-lock.json
      if (fullPath === outputFile || item === 'package-lock.json') {
        return;
      }

      try {
        const fileContent = fs.readFileSync(fullPath, 'utf8');
        // Calculamos la ruta relativa para incluirla como comentario
        const relativePath = path
          .relative(rootDir, fullPath)
          .replace(/\\/g, '/');

        // Siempre agregamos la ruta y el contenido del archivo, sin importar su formato
        outputContent += `---\n // ${relativePath}\n\n${fileContent}\n---\n`;
      } catch (error) {
        console.error(`Error al leer el archivo ${fullPath}:`, error);
      }
    }
  });
}

// Iniciamos el recorrido desde el directorio raíz
traverseDirectory(rootDir);

// Escribimos el contenido acumulado en el archivo de salida.
fs.writeFileSync(outputFile, outputContent, 'utf8');
console.log(`Archivo generado: ${outputFile}`);

---
---
 // README.md

# Sitio Panadería "Pan Comido" - Test Frontend

Demo Live: [Pan Comido](https://pancomido-seven.vercel.app/)

## Descripción

El segundo hito consiste en el desarrollo de la aplicación cliente con React, en donde debes:

- Crear un nuevo proyecto con las dependencias acorde al diseño y temática definida en el hito anterior.
- Usar los componentes para la reutilización de código y separación de secciones integrando los hooks necesarios que correspondan.
- Usar React Router para la navegación de vistas por rutas.
- Utilizar Context API para el manejo de estado global.
- Preparar la aplicación para el consumo de datos siguiendo el contrato definido en el hito anterior.

Se recomienda utilizar un framework de CSS para agilizar la construcción de la interfaz
gráfica del proyecto.

Requerimientos
1. Crear un nuevo proyecto usando npx e instalar las dependencias.
2. Utilizar React Router para la navegación entre rutas.
3. Reutilizar componentes haciendo uso del paso de props y renderización dinámica.
4. Hacer uso de los hooks para un desarrollo ágil y reactivo.
5. Utilizar Context para el manejo del estado global.

Desafío Latam

---
---
 // src/.env

VITE_CRYPTOJS_SECRET = "your_secret_key"
VITE_API_URL = "http://localhost:3000"
---
---
 // src/App.css


---
---
 // src/App.jsx

import "./App.css";
import { ToastContainer } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import { AuthProvider } from "./context/AuthProvider";
import { RouterManager } from "./router/RouterManager";
import { CartProvider } from "./context/CartProvider";
import { ProductProvider } from "./context/ProductProvider";

function App() {
  return (
    <>
      <ToastContainer />
      <AuthProvider>
        <CartProvider>
          <ProductProvider>
            <RouterManager />
          </ProductProvider>
        </CartProvider>
      </AuthProvider>
    </>
  );
}

export default App;

---
---
 // src/components/admin/EditarCatalogo.jsx

// src/components/admin/EditarCatalogo.jsx
import { useState, useEffect } from "react";
import { Button, Switch, Modal } from "antd";
import { toast } from "react-toastify";
import { useAuth } from "../../hooks/useAuth";
import ProductForm from "./ProductForm";
import { useProductImages } from "../../hooks/useProductImages";

export const EditarCatalogo = () => {
  const { session } = useAuth();
  const API_URL = import.meta.env.VITE_API_URL;

  const [products, setProducts] = useState([]);
  const [availableCategories, setAvailableCategories] = useState([]);
  const [stockEdits, setStockEdits] = useState({});
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [modalTitle, setModalTitle] = useState("Agregar nuevo");
  const [editingProductId, setEditingProductId] = useState(null);
  const [formErrors, setFormErrors] = useState({});
  const [isModalSubmitting, setIsModalSubmitting] = useState(false);
  const [loadingStock, setLoadingStock] = useState({});
  const [isDeletingSelected, setIsDeletingSelected] = useState(false);
  const [formData, setFormData] = useState({
    product: "",
    price: "",
    stock: "",
    ingredients: "",
    description: "",
    nutrition: "",
    weight: "",
    categories: [],
    isAvailable: false,
  });

  // Usamos el hook para manejo de imágenes (4 slots)
  const {
    productImages,
    setProductImages,
    fileInputsRef,
    handleFileSelect,
    handleFileChange,
    handleDeleteImage,
  } = useProductImages(API_URL, session, editingProductId);

  // Función para cargar productos desde el endpoint GET /admin/products
  const fetchProducts = () => {
    fetch(`${API_URL}/api/admin/products`, {
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${session?.token}`,
      },
    })
      .then((res) => res.json())
      .then((data) => {
        const mapped = data.map((prod) => ({
          ...prod,
          name: prod.product, // renombramos para la UI
          isAvailable: prod.available,
          selectedForDeletion: false,
        }));
        setProducts(mapped);
      })
      .catch((err) => {
        console.error("Error fetching products:", err);
        toast.error(err.message, { position: "bottom-right" });
      });
  };

  // Función para cargar categorías desde el endpoint GET /api/categories
  const fetchAvailableCategories = () => {
    fetch(`${API_URL}/api/categories`, {
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${session?.token}`,
      },
    })
      .then((res) => res.json())
      .then((data) => setAvailableCategories(data))
      .catch((err) => {
        console.error("Error fetching categories:", err);
        toast.error("Error al cargar categorías", { position: "bottom-right" });
      });
  };

  useEffect(() => {
    if (session?.token) {
      fetchProducts();
      fetchAvailableCategories();
    }
  }, [API_URL, session]);

  // Abre el modal para agregar un producto nuevo
  const openModalForAdd = () => {
    setModalTitle("Agregar nuevo");
    setEditingProductId(null);
    setFormData({
      product: "",
      price: "",
      stock: "",
      ingredients: "",
      description: "",
      nutrition: "",
      weight: "",
      categories: [],
      isAvailable: false,
    });
    setProductImages([null, null, null, null]);
    setFormErrors({});
    setIsModalOpen(true);
  };

  // Abre el modal para editar un producto existente
  const openModalForEdit = (product) => {
    setModalTitle("Editando producto");
    setEditingProductId(product.id);
    setFormData({
      product: product.name || "",
      price: product.price || "",
      stock: product.stock || "",
      ingredients: product.ingredients || "",
      description: product.description || "",
      nutrition: product.nutrition || "",
      weight: product.weight || "",
      categories: product.categories || [],
      isAvailable: product.isAvailable,
    });
    // Se espera que product.images contenga un arreglo con hasta 4 objetos { secure_url }
    setProductImages(
      product.images && product.images.length
        ? product.images
        : [null, null, null, null]
    );
    setFormErrors({});
    setIsModalOpen(true);
  };

  const handleCancelModal = () => {
    setIsModalOpen(false);
  };

  // Validación del formulario: todos los campos obligatorios y al menos imagen principal
  const validateForm = () => {
    const errors = {};
    if (!formData.product) errors.product = true;
    if (formData.price === "") errors.price = true;
    if (formData.stock === "") errors.stock = true;
    if (!formData.ingredients) errors.ingredients = true;
    if (!formData.description) errors.description = true;
    if (!formData.nutrition) errors.nutrition = true;
    if (formData.weight === "") errors.weight = true;
    if (!formData.categories || formData.categories.length === 0)
      errors.categories = true;
    if (!productImages[0]) errors.productImages = true;
    return errors;
  };

  // Función handleSaveModal: maneja la creación o edición del producto,
  // incluyendo la subida de imágenes para productos nuevos.
  const handleSaveModal = async () => {
    const errors = validateForm();
    setFormErrors(errors);
    if (Object.keys(errors).length > 0) {
      toast.error(
        "Completa todos los campos obligatorios y carga al menos una imagen.",
        { position: "bottom-right" }
      );
      return;
    }
    setIsModalSubmitting(true);
    const payload = {
      product: formData.product,
      price: Number(formData.price),
      stock: Number(formData.stock),
      ingredients: formData.ingredients,
      description: formData.description,
      nutrition: formData.nutrition,
      weight: Number(formData.weight),
      categories: formData.categories,
      available: formData.isAvailable,
      images: [], // se completará luego
    };
    try {
      let response, data, productId;
      if (!editingProductId) {
        // CREAR PRODUCTO SIN IMÁGENES (primero crear el producto)
        response = await fetch(`${API_URL}/api/admin/products`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${session?.token}`,
          },
          body: JSON.stringify({ ...payload, images: [] }),
        });
        data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || "Error al agregar producto");
        }
        productId = data.id;
        // Para cada slot que tenga un objeto File (nuevo), subirlo usando el ID recién creado
        const uploadedImages = [];
        for (let i = 0; i < productImages.length; i++) {
          const slotImage = productImages[i];
          if (slotImage && slotImage instanceof File) {
            const formDataObj = new FormData();
            formDataObj.append("image", slotImage);
            formDataObj.append("productId", productId);
            const res = await fetch(`${API_URL}/api/upload`, {
              method: "POST",
              headers: {
                Authorization: `Bearer ${session?.token}`,
              },
              body: formDataObj,
            });
            const uploadResult = await res.json();
            if (!res.ok) {
              throw new Error(uploadResult.error || "Error al subir imagen");
            }
            uploadedImages[i] = {
              secure_url: uploadResult.secure_url,
              public_id: uploadResult.public_id,
            };
          } else {
            uploadedImages[i] = slotImage;
          }
        }
        // Asegurar que exista al menos imagen principal en el slot 0
        if (
          !uploadedImages[0] &&
          uploadedImages.filter((img) => img !== null).length === 1
        ) {
          const firstImg = uploadedImages.find((img) => img !== null);
          uploadedImages[0] = firstImg;
        }
        // Actualizar la información de imágenes en la BD usando el endpoint POST /product-images/save-images
        const imagesPayload = {
          productId,
          images: uploadedImages.filter((img) => img !== null),
        };
        const imagesResponse = await fetch(
          `${API_URL}/api/product-images/save-images`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${session?.token}`,
            },
            body: JSON.stringify(imagesPayload),
          }
        );
        const imagesData = await imagesResponse.json();
        if (!imagesResponse.ok) {
          throw new Error(imagesData.error || "Error al guardar imágenes");
        }
        toast.success("Producto agregado correctamente", {
          position: "bottom-right",
        });
      } else {
        // EDICIÓN: Se envía el payload con las imágenes actuales (ya sean subidas o File convertidos previamente)
        response = await fetch(
          `${API_URL}/api/admin/products/${editingProductId}`,
          {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${session?.token}`,
            },
            body: JSON.stringify({
              ...payload,
              images: productImages.filter((img) => img !== null),
            }),
          }
        );
        data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || "Error al editar producto");
        }
        toast.success("Producto actualizado correctamente", {
          position: "bottom-right",
        });
      }
      setIsModalOpen(false);
      fetchProducts();
      fetchAvailableCategories();
    } catch (error) {
      toast.error(error.message, { position: "bottom-right" });
    } finally {
      setIsModalSubmitting(false);
    }
  };

  // Actualizar stock (PUT /admin/products/{id}/stock)
  const handleSaveStock = async (id) => {
    const newStockValue = stockEdits[id];
    if (newStockValue !== undefined) {
      const parsedStock = Number(newStockValue);
      setLoadingStock((prev) => ({ ...prev, [id]: true }));
      try {
        const response = await fetch(
          `${API_URL}/api/admin/products/${id}/stock`,
          {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${session?.token}`,
            },
            body: JSON.stringify({ stock: parsedStock }),
          }
        );
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || "Error al actualizar stock");
        }
        toast.success("Stock actualizado", { position: "bottom-right" });
        fetchProducts();
      } catch (error) {
        toast.error(error.message, { position: "bottom-right" });
      } finally {
        setLoadingStock((prev) => ({ ...prev, [id]: false }));
      }
    }
  };

  // Actualizar disponibilidad (PUT /admin/products/{id})
  const handleToggleAvailability = (id, checked) => {
    const product = products.find((p) => p.id === id);
    fetch(`${API_URL}/api/admin/products/${id}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${session?.token}`,
      },
      body: JSON.stringify({
        product: product.name,
        price: product.price,
        stock: product.stock,
        ingredients: product.ingredients,
        description: product.description,
        nutrition: product.nutrition,
        weight: product.weight,
        categories: product.categories || [],
        available: checked,
      }),
    })
      .then((res) => res.json())
      .then(() => fetchProducts())
      .catch((err) => {
        toast.error(err.message, { position: "bottom-right" });
      });
  };

  // Marcar para eliminación
  const handleSelectForDeletion = (id, isChecked) => {
    setProducts((prev) =>
      prev.map((prod) =>
        prod.id === id ? { ...prod, selectedForDeletion: isChecked } : prod
      )
    );
  };

  // Eliminar productos seleccionados (DELETE /admin/products)
  const handleDeleteSelected = () => {
    const selectedIds = products
      .filter((p) => p.selectedForDeletion)
      .map((p) => p.id);
    if (selectedIds.length === 0) return;
    setIsDeletingSelected(true);
    Modal.confirm({
      title: "¿Estás seguro?",
      content: `Vas a eliminar ${selectedIds.length} productos`,
      okText: "Eliminar",
      cancelText: "Cancelar",
      onOk: async () => {
        try {
          const response = await fetch(`${API_URL}/api/admin/products`, {
            method: "DELETE",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${session?.token}`,
            },
            body: JSON.stringify({ productIds: selectedIds }),
          });
          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Error al eliminar productos");
          }
          toast.success("Productos eliminados", { position: "bottom-right" });
          fetchProducts();
          fetchAvailableCategories();
        } catch (error) {
          toast.error(error.message, { position: "bottom-right" });
        } finally {
          setIsDeletingSelected(false);
        }
      },
      onCancel: () => {
        setIsDeletingSelected(false);
      },
    });
  };

  // Desmarcar todos los productos seleccionados
  const handleEmptySelected = () => {
    setProducts((prev) =>
      prev.map((prod) => ({ ...prod, selectedForDeletion: false }))
    );
  };

  return (
    <div className="flex min-h-screen">
      <main className="flex-1 p-4">
        {/* Sección de acciones, botones, etc. */}
        <div className="mb-4">
          <Button
            type="primary"
            className="mr-6"
            onClick={openModalForAdd}
            disabled={isDeletingSelected || isModalSubmitting}
          >
            Agregar Nuevo Producto
          </Button>
          <Button
            type="dashed"
            className="mr-6"
            onClick={handleEmptySelected}
            disabled={isDeletingSelected || isModalSubmitting}
          >
            Desmarcar Seleccionados
          </Button>
          <Button
            danger
            onClick={handleDeleteSelected}
            disabled={isDeletingSelected || isModalSubmitting}
          >
            Eliminar Seleccionados
          </Button>
        </div>

        {/* Contenedor de la lista de productos con scroll */}
        <div className="max-h-[calc(100vh-200px)] max-w-4xl overflow-y-auto p-8">
          {products.map((product) => {
            const tempStock = stockEdits[product.id];
            const stockInputValue =
              tempStock !== undefined ? tempStock : product.stock;
            return (
              <div key={product.id} className="flex items-start mb-4">
                <div className="w-[100px] h-[100px] bg-gray-400 mr-4 flex items-center justify-center">
                  {product.url_img ? (
                    <img
                      src={product.url_img}
                      alt={product.name}
                      className="w-full h-full object-cover rounded"
                    />
                  ) : (
                    "Imagen"
                  )}
                </div>
                <div className="mr-8">
                  <strong>{product.name}</strong>
                  <p>Stock actual: {product.stock} unidades</p>
                  <div className="mb-2 flex items-center gap-2">
                    <label className="mr-2">Modificar stock:</label>
                    <input
                      type="text"
                      className="w-16 text-right appearance-none border border-gray-300 rounded px-1"
                      value={stockInputValue}
                      onChange={(e) =>
                        setStockEdits((prev) => ({
                          ...prev,
                          [product.id]: e.target.value.replace(/\D/g, ""),
                        }))
                      }
                    />
                    <Button
                      className="ml-2"
                      type="default"
                      onClick={() => handleSaveStock(product.id)}
                      disabled={loadingStock[product.id]}
                    >
                      Guardar
                    </Button>
                  </div>
                  <Button
                    type="link"
                    className="p-0"
                    onClick={() => openModalForEdit(product)}
                    disabled={isDeletingSelected || isModalSubmitting}
                  >
                    Editar datos producto
                  </Button>
                </div>
                <div className="mr-4">
                  <div className="mb-2">
                    <span className="mr-1">Disponible:</span>
                    <Switch
                      checked={product.isAvailable}
                      onChange={(checked) =>
                        handleToggleAvailability(product.id, checked)
                      }
                    />
                  </div>
                </div>
                <div className="mt-1">
                  <label>
                    <input
                      type="checkbox"
                      className="mr-1"
                      checked={product.selectedForDeletion}
                      onChange={(e) =>
                        handleSelectForDeletion(product.id, e.target.checked)
                      }
                    />
                    Eliminar
                  </label>
                </div>
              </div>
            );
          })}
        </div>
        {/* Formulario para agregar/editar producto */}
        <ProductForm
          modalTitle={modalTitle}
          isModalOpen={isModalOpen}
          confirmLoading={isModalSubmitting}
          formData={formData}
          setFormData={setFormData}
          formErrors={formErrors}
          availableCategories={availableCategories}
          productImages={productImages}
          fileInputsRef={fileInputsRef}
          handleFileSelect={handleFileSelect}
          handleFileChange={handleFileChange}
          handleDeleteImage={handleDeleteImage}
          onCancel={handleCancelModal}
          onSave={handleSaveModal}
        />
      </main>
    </div>
  );
};

export default EditarCatalogo;

---
---
 // src/components/admin/EditarUsuarios.jsx

// src/components/admin/EditarUsuarios.jsx

import { useEffect, useState } from "react";

export const EditarUsuarios = () => {
  const [usuarios, setUsuarios] = useState([]);

  useEffect(() => {
    // Simula la carga de usuarios
    setTimeout(() => {
      setUsuarios([
        { id: 1, username: "admin", role: "admin" },
        { id: 2, username: "usuario1", role: "customer" },
        { id: 3, username: "usuario2", role: "customer" },
      ]);
    }, 1000);
  }, []);

  if (usuarios.length === 0) return <p>Cargando usuarios...</p>;

  return (
    <div className="p-4">
      <h3 className="text-2xl font-bold mb-4">Editar Usuarios</h3>
      <ul className="space-y-2">
        {usuarios.map((usuario) => (
          <li
            key={usuario.id}
            className="flex justify-between items-center border p-2 rounded-md"
          >
            <span>
              {usuario.username} - {usuario.role}
            </span>
            <button className="bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700 transition">
              Editar
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};

---
---
 // src/components/admin/PedidosHistoricos.jsx

// src/components/admin/PedidosHistoricos.jsx

import { useEffect, useState } from "react";

export const PedidosHistoricos = () => {
  const [historico, setHistorico] = useState([]);

  useEffect(() => {
    // Simula la carga del historial de pedidos
    setTimeout(() => {
      setHistorico([
        { id: 201, customer: "Cliente 3", total: 250, status: "Entregado" },
        { id: 202, customer: "Cliente 4", total: 300, status: "Entregado" },
      ]);
    }, 1000);
  }, []);

  if (historico.length === 0) return <p>No hay historial de pedidos.</p>;

  return (
    <div className="p-4">
      <h3 className="text-2xl font-bold mb-4">Pedidos Históricos</h3>
      <ul className="space-y-2">
        {historico.map((pedido) => (
          <li key={pedido.id} className="border p-2 rounded-md">
            <p>
              <strong>Pedido #{pedido.id}</strong>
            </p>
            <p>Cliente: {pedido.customer}</p>
            <p>Total: ${pedido.total}</p>
            <p>Status: {pedido.status}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

---
---
 // src/components/admin/PedidosPendientes.jsx

// src/components/admin/PedidosPendientes.jsx

import { useEffect, useState } from "react";

export const PedidosPendientes = () => {
  const [pedidos, setPedidos] = useState([]);

  useEffect(() => {
    // Simula la carga de pedidos pendientes
    setTimeout(() => {
      setPedidos([
        { id: 101, customer: "Cliente 1", total: 150, status: "Pendiente" },
        { id: 102, customer: "Cliente 2", total: 200, status: "Pendiente" },
      ]);
    }, 1000);
  }, []);

  if (pedidos.length === 0) return <p>No hay pedidos pendientes.</p>;

  return (
    <div className="p-4">
      <h3 className="text-2xl font-bold mb-4">Pedidos Pendientes</h3>
      <ul className="space-y-2">
        {pedidos.map((pedido) => (
          <li key={pedido.id} className="border p-2 rounded-md">
            <p>
              <strong>Pedido #{pedido.id}</strong>
            </p>
            <p>Cliente: {pedido.customer}</p>
            <p>Total: ${pedido.total}</p>
            <p>Status: {pedido.status}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

---
---
 // src/components/admin/ProductForm.jsx

// src/components/admin/ProductForm.jsx
import React from "react";
import { Modal, Switch, Button, Select, Input } from "antd";

const { Option } = Select;

const ProductForm = ({
  modalTitle,
  isModalOpen,
  confirmLoading,
  formData,
  setFormData,
  formErrors,
  availableCategories,
  productImages,
  fileInputsRef,
  handleFileSelect,
  handleFileChange,
  handleDeleteImage,
  onCancel,
  onSave,
}) => {
  return (
    <Modal
      title={modalTitle}
      open={isModalOpen}
      onOk={onSave}
      onCancel={onCancel}
      confirmLoading={confirmLoading}
      okText="Guardar"
      cancelText="Cancelar"
    >
      <div className="flex gap-4">
        {/* Columna de imágenes: 4 cuadros */}
        <div className="flex flex-col gap-4">
          {Array(4)
            .fill(null)
            .map((_, index) => (
              <div
                key={index}
                className={`relative w-[120px] h-[120px] flex items-center justify-center border ${
                  index === 0 ? "border-4 border-blue-500" : "border-gray-300"
                } rounded bg-gray-300 cursor-pointer`}
                title={
                  index === 0 ? "Imagen principal del producto en catálogo" : ""
                }
                onClick={() => handleFileSelect(index)}
              >
                {productImages[index] ? (
                  // Si es File se muestra preview usando URL.createObjectURL; sino se usa secure_url
                  typeof productImages[index] === "object" &&
                  productImages[index] instanceof File ? (
                    <img
                      src={URL.createObjectURL(productImages[index])}
                      alt={`Imagen ${index + 1}`}
                      className="w-full h-full object-cover rounded"
                    />
                  ) : (
                    <img
                      src={productImages[index].secure_url}
                      alt={`Imagen ${index + 1}`}
                      className="w-full h-full object-cover rounded"
                    />
                  )
                ) : (
                  <span>Cargar Imagen {index + 1}</span>
                )}
                {productImages[index] && (
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleDeleteImage(index);
                    }}
                    className="absolute top-1 right-1 bg-white text-xs px-1 py-0.5 rounded"
                  >
                    Eliminar
                  </button>
                )}
                <input
                  type="file"
                  accept="image/*"
                  ref={fileInputsRef.current[index]}
                  style={{ display: "none" }}
                  onChange={(e) => handleFileChange(e, index)}
                />
              </div>
            ))}
        </div>
        {/* Columna del formulario */}
        <div className="flex-1">
          <div className="mb-4">
            <label className="block">Nombre:</label>
            <Input
              value={formData.product}
              onChange={(e) =>
                setFormData({ ...formData, product: e.target.value })
              }
              status={formErrors.product ? "error" : ""}
            />
          </div>
          <div className="mb-4 flex gap-4">
            <div className="flex-1">
              <label className="block">Valor:</label>
              <Input
                type="number"
                value={formData.price}
                onChange={(e) =>
                  setFormData({ ...formData, price: e.target.value })
                }
                status={formErrors.price ? "error" : ""}
              />
            </div>
            <div className="flex-1">
              <label className="block">Stock:</label>
              <Input
                type="number"
                value={formData.stock}
                onChange={(e) =>
                  setFormData({ ...formData, stock: e.target.value })
                }
                status={formErrors.stock ? "error" : ""}
              />
            </div>
          </div>
          <div className="mb-4">
            <label className="block">Ingredientes:</label>
            <Input.TextArea
              rows={2}
              value={formData.ingredients}
              onChange={(e) =>
                setFormData({ ...formData, ingredients: e.target.value })
              }
              status={formErrors.ingredients ? "error" : ""}
            />
          </div>
          <div className="mb-4">
            <label className="block">Descripción:</label>
            <Input.TextArea
              rows={2}
              value={formData.description}
              onChange={(e) =>
                setFormData({ ...formData, description: e.target.value })
              }
              status={formErrors.description ? "error" : ""}
            />
          </div>
          <div className="mb-4">
            <label className="block">Nutricionales:</label>
            <Input.TextArea
              rows={2}
              value={formData.nutrition}
              onChange={(e) =>
                setFormData({ ...formData, nutrition: e.target.value })
              }
              status={formErrors.nutrition ? "error" : ""}
            />
          </div>
          <div className="mb-4 flex gap-4">
            <div className="w-1/3">
              <label className="block">Peso aprox(gr):</label>
              <Input
                value={formData.weight}
                onChange={(e) =>
                  setFormData({ ...formData, weight: e.target.value })
                }
                status={formErrors.weight ? "error" : ""}
              />
            </div>
            <div className="w-2/3">
              <label className="block">Categorías:</label>
              <Select
                mode="tags"
                style={{ width: "100%" }}
                placeholder="Ingresa categorías y presiona Enter"
                onChange={(tagsArray) =>
                  setFormData({ ...formData, categories: tagsArray })
                }
                value={formData.categories}
                status={formErrors.categories ? "error" : ""}
                options={availableCategories.map((cat) => ({
                  value: cat.category,
                  label: cat.category,
                }))}
              />
            </div>
          </div>
          <div className="mb-4">
            <label className="mr-2">Disponible:</label>
            <input
              type="checkbox"
              checked={formData.isAvailable}
              onChange={(e) =>
                setFormData({ ...formData, isAvailable: e.target.checked })
              }
            />
          </div>
        </div>
      </div>
    </Modal>
  );
};

export default ProductForm;

---
---
 // src/components/admin/ResumenTienda.jsx

// src/components/admin/ResumenTienda.jsx

import { useEffect, useState } from "react";

export const ResumenTienda = () => {
  const [data, setData] = useState(null);

  useEffect(() => {
    // Simula la carga de datos. En un caso real, realiza una llamada a la API.
    setTimeout(() => {
      setData({
        ventas: 12000,
        productos: 150,
        pedidos: 75,
      });
    }, 1000);
  }, []);

  if (!data) return <p>Cargando resumen de la tienda...</p>;

  return (
    <div className="p-4">
      <h3 className="text-2xl font-bold mb-4">Resumen General de la Tienda</h3>
      <div className="space-y-2">
        <p>
          <strong>Ventas Totales:</strong> ${data.ventas}
        </p>
        <p>
          <strong>Número de Productos:</strong> {data.productos}
        </p>
        <p>
          <strong>Total de Pedidos:</strong> {data.pedidos}
        </p>
      </div>
    </div>
  );
};

---
---
 // src/components/Categories.jsx

// src/components/Categories.jsx
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";

export const Categories = () => {
  const [categories, setCategories] = useState([]);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchCategories = async () => {
      try {
        const response = await fetch(
          `${import.meta.env.VITE_API_URL}/api/categories`,
          {
            headers: {
              "Content-Type": "application/json",
            },
          }
        );
        if (!response.ok) {
          throw new Error("Error al obtener categorías");
        }
        const data = await response.json();

        setCategories(data.map((item) => item.category));
      } catch (error) {
        console.error(error);
      }
    };

    fetchCategories();
  }, []);

  const handleCategoryClick = (category) => {
    // Navega a /catalog con el parámetro category y elimina cualquier search previo.
    navigate(`/catalog?category=${encodeURIComponent(category)}`);
  };

  return (
    <section className="my-8 w-full">
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 pt-4 pb-4 rounded-lg w-full">
        {categories.map((category) => (
          <div
            key={category}
            onClick={() => handleCategoryClick(category)}
            className="cursor-pointer p-4 bg-[#F5E1A4] rounded-lg flex justify-center items-center text-center font-semibold"
          >
            {category}
          </div>
        ))}
      </div>
    </section>
  );
};

---
---
 // src/components/Credits.jsx

// src/components/Credits.jsx

import { useEffect } from "react";

export const Credits = () => {
  // Inyecta el link de Google Fonts para "Fira Code"
  useEffect(() => {
    const link = document.createElement("link");
    link.href =
      "https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;700&display=swap";
    link.rel = "stylesheet";
    document.head.appendChild(link);
  }, []);

  return (
    <div className="bg-[#111a28] text-white text-center text-xs p-1 font-mono">
      <p style={{ fontFamily: '"Fira Code", monospace' }}>
        Desarrollado por{" "}
        <a
          href="https://www.alvarocortes.cl"
          target="_blank"
          rel="noopener noreferrer"
          style={{
            fontWeight: "bold",
            textDecoration: "underline",
            textDecorationColor: "transparent",
          }}
          onMouseEnter={(e) =>
            (e.currentTarget.style.textDecorationColor = "white")
          }
          onMouseLeave={(e) =>
            (e.currentTarget.style.textDecorationColor = "transparent")
          }
        >
          Alvaro <span style={{ textDecoration: "underline" }}>#Pelusa</span>{" "}
          Cortés
        </a>{" "}
        © {new Date().getFullYear()}
      </p>
    </div>
  );
};

---
---
 // src/components/customer/MiCuenta.jsx

// src/components/customer/MiCuenta.jsx

import { useAuth } from "../../hooks/useAuth";

export const MiCuenta = () => {
  const { session } = useAuth();

  return (
    <div className="p-4">
      <h3 className="text-xl font-bold mb-2">
        Bienvenido, {session?.name || "Usuario"}
      </h3>
      <p className="mb-4">Email: {session?.email || "No definido"}</p>
      <h4 className="text-lg font-semibold mb-2">Compras recientes:</h4>
      <ul className="list-disc ml-6">
        {/* Aquí podrías mapear tus compras recientes */}
        <li>Compra #1234 - Estado: Enviado</li>
        <li>Compra #1235 - Estado: En proceso</li>
        <li>Compra #1236 - Estado: Cancelada</li>
      </ul>
    </div>
  );
};

---
---
 // src/components/customer/MisDatos.jsx

// src/components/customer/MisDatos.jsx

import { useState } from "react";
import { toast } from "react-toastify";

export const MisDatos = () => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    // Aquí llamarías a una API para actualizar los datos
    toast.success("Datos actualizados correctamente", {
      position: "bottom-right",
      autoClose: 3000,
      theme: "dark",
    });
  };

  return (
    <div className="p-4">
      <h3 className="text-xl font-bold mb-4">Mis Datos</h3>
      <form onSubmit={handleSubmit} className="space-y-4">
        <div>
          <label htmlFor="name" className="block text-gray-700">
            Nombre
          </label>
          <input
            type="text"
            id="name"
            name="name"
            value={formData.name}
            onChange={handleChange}
            className="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-300"
          />
        </div>
        <div>
          <label htmlFor="email" className="block text-gray-700">
            Email
          </label>
          <input
            type="email"
            id="email"
            name="email"
            value={formData.email}
            onChange={handleChange}
            className="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-300"
          />
        </div>
        <button
          type="submit"
          className="w-full bg-blue-600 text-white p-2 rounded-md hover:bg-blue-700 transition duration-300"
        >
          Guardar Cambios
        </button>
      </form>
    </div>
  );
};

---
---
 // src/components/customer/MisDirecciones.jsx

// src/components/customer/MisDirecciones.jsx

import { useEffect, useState } from "react";

export const MisDirecciones = () => {
  const [direcciones, setDirecciones] = useState([]);

  useEffect(() => {
    // Simula la carga de direcciones. En un caso real, obtendrías estos datos de una API o estado global.
    setDirecciones([
      { id: 1, direccion: "Calle Falsa 123, Ciudad, País" },
      { id: 2, direccion: "Avenida Siempre Viva 742, Ciudad, País" },
    ]);
  }, []);

  return (
    <div className="p-4">
      <h3 className="text-xl font-bold mb-4">Mis Direcciones</h3>
      {direcciones.length === 0 ? (
        <p>No tienes direcciones registradas.</p>
      ) : (
        <ul className="space-y-2">
          {direcciones.map((dir) => (
            <li
              key={dir.id}
              className="border p-2 rounded-md flex justify-between items-center"
            >
              <span>{dir.direccion}</span>
              <button className="text-blue-600 hover:underline">Editar</button>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

---
---
 // src/components/customer/MisFavoritos.jsx

// src/components/customer/MisFavoritos.jsx

import { useEffect, useState } from "react";
import { Link } from "react-router-dom";

export const MisFavoritos = () => {
  const [favoritos, setFavoritos] = useState([]);

  useEffect(() => {
    // Simula la carga de favoritos. En un caso real, obtendrías estos datos de una API o del estado global.
    setFavoritos([
      { id: 101, title: "Producto Favorito 1", image: "/ruta/a/imagen1.jpg" },
      { id: 102, title: "Producto Favorito 2", image: "/ruta/a/imagen2.jpg" },
    ]);
  }, []);

  return (
    <div className="p-4">
      <h3 className="text-xl font-bold mb-4">Mis Favoritos</h3>
      {favoritos.length === 0 ? (
        <p>No tienes productos favoritos.</p>
      ) : (
        <div className="grid grid-cols-2 gap-4">
          {favoritos.map((item) => (
            <Link
              key={item.id}
              to={`/product/${item.id}`}
              className="border p-2 rounded-md flex flex-col items-center hover:shadow-lg transition"
            >
              <img
                src={item.image}
                alt={item.title}
                className="w-full h-32 object-cover mb-2"
              />
              <p className="text-center">{item.title}</p>
            </Link>
          ))}
        </div>
      )}
    </div>
  );
};

---
---
 // src/components/customer/MisPedidos.jsx

// src/components/customer/MisPedidos.jsx

import { useEffect, useState } from "react";

export const MisPedidos = () => {
  const [pedidos, setPedidos] = useState([]);

  useEffect(() => {
    // Aquí simulas la carga de pedidos. En un caso real, llamarías a una API.
    setPedidos([
      { id: 1, fecha: "2025-01-15", estado: "Enviado" },
      { id: 2, fecha: "2025-02-03", estado: "En proceso" },
      { id: 3, fecha: "2025-02-10", estado: "Entregado" },
    ]);
  }, []);

  return (
    <div className="p-4">
      <h3 className="text-xl font-bold mb-4">Mis Pedidos</h3>
      {pedidos.length === 0 ? (
        <p>No has realizado pedidos aún.</p>
      ) : (
        <ul className="space-y-2">
          {pedidos.map((pedido) => (
            <li key={pedido.id} className="border p-2 rounded-md">
              <p>Pedido #{pedido.id}</p>
              <p>Fecha: {pedido.fecha}</p>
              <p>Estado: {pedido.estado}</p>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

---
---
 // src/components/Footer.jsx

// src/components/Footer.jsx

import logo from "../assets/images/logoRedondo_cortado.png";

export const Footer = () => {
  return (
    <footer className="bg-[#F5E1A4] text-[#262011] text-left p-4 mt-8 flex items-center">
      <div className="flex items-center gap-4 w-full max-w-[80rem] mx-auto justify-center">
        {/* Logo */}
        <img src={logo} alt="Pan Comido Logo" className="h-24" />

        {/* Divisor */}
        <div className="h-16 ml-10 w-[2px] bg-[#262011]"></div>

        {/* Texto */}
        <div className="ml-10">
          <p className="font-bold">Pan Comido</p>
          <p>Panadería artesanal en Caldera, Atacama</p>
          <p>📍 Dirección: Calle Falsa 123, Caldera, Atacama</p>
          <p>📞 Teléfono: +56 9 1234 5678</p>
          <p>📧 Email: contacto@pancomido.cl</p>
        </div>
      </div>
    </footer>
  );
};

---
---
 // src/components/Header.jsx

// src/components/Header.jsx

import { Link, useNavigate } from "react-router-dom";
import { useAuth } from "../hooks/useAuth";
import { useCart } from "../hooks/useCart"; // Solo importamos useCart
import { FiLogOut } from "react-icons/fi";
import { IoCartOutline } from "react-icons/io5";
import { LuUserRound } from "react-icons/lu";
import logo from "../assets/images/logoWeb_cortado.png";
import { HeaderSearch } from "../components/SearchBar";
import { toast } from "react-toastify";

export const Header = () => {
  const { session, logout } = useAuth();
  const { cart, clearCart } = useCart();
  const navigate = useNavigate();

  const handleLogout = () => {
    // Limpia el carrito
    clearCart();
    localStorage.removeItem("cart");

    // Llama a logout y muestra la notificación
    logout();
    toast.info("Sesión de usuario cerrada", {
      position: "bottom-right",
      autoClose: 3000,
      hideProgressBar: false,
      closeOnClick: true,
      pauseOnFocusLoss: true,
      draggable: true,
      pauseOnHover: true,
      theme: "dark",
      newestOnTop: true,
    });
    setTimeout(() => {
      navigate("/");
    }, 200);
  };

  const totalItems = cart.reduce(
    (total, product) => total + product.quantity,
    0
  );

  return (
    <header className="bg-[#F5E1A4] text-[#262011] p-4">
      <div className="grid grid-cols-4 items-center h-[10rem] max-w-[80rem] mx-auto">
        <div className="flex justify-center items-center h-full col-span-1">
          <Link to="/">
            <img src={logo} alt="Pan Comido" className="h-35" />
          </Link>
        </div>
        <div className="grid grid-rows-2 gap-2 h-full w-full col-span-3">
          <div className="flex justify-center items-center gap-6">
            <HeaderSearch />
            <Link
              to={session?.token ? "/profile" : "/auth/login"}
              className="text-lg border border-black p-2 rounded-md font-semibold flex items-center justify-center hover:bg-gray-100 hover:text-gray-700 transition"
              style={{ width: "7.5rem", height: "3rem" }}
            >
              {session?.token ? "Perfil" : "Login"}{" "}
              <LuUserRound className="ml-2 text-2xl hover:text-gray-700 transition" />
            </Link>
            {session?.token && (
              <button
                onClick={handleLogout}
                className="text-lg border border-black p-2 rounded-md font-semibold flex text-center items-center justify-center text-black hover:bg-red-100 hover:text-gray-700 transition duration-300 cursor-pointer"
                style={{ width: "7.5rem", height: "3rem" }}
              >
                Logout{" "}
                <FiLogOut
                  size={20}
                  className="ml-2 hover:text-gray-700 transition"
                />
              </button>
            )}
            <Link
              to="/cart"
              className="text-lg border border-black p-2 rounded-md font-semibold flex items-center justify-center relative hover:bg-gray-100 hover:text-gray-700 transition"
              style={{ width: "7.5rem", height: "3rem" }}
            >
              {totalItems > 0 ? (
                <>
                  <IoCartOutline className="text-2xl mr-1 hover:text-gray-700 transition" />{" "}
                  ({totalItems})
                </>
              ) : (
                <>
                  Carrito{" "}
                  <IoCartOutline className="text-2xl ml-1 hover:text-gray-700 transition" />
                </>
              )}
            </Link>
          </div>
          <nav className="flex justify-center items-center gap-6 text-[#262011] text-2xl w-full font-semibold">
            <Link
              to="/catalog"
              className="transition hover:underline underline-offset-14"
            >
              Catálogo
            </Link>
            <Link
              to="/contact"
              className="transition hover:underline underline-offset-14"
            >
              Contacto
            </Link>
          </nav>
        </div>
      </div>
    </header>
  );
};

---
---
 // src/components/LoginForm.jsx

// src/components/LoginForm.jsx

import { useState } from "react";
import { useAuth } from "../hooks/useAuth";
import { useNavigate } from "react-router-dom";
import { toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";

export const LoginForm = () => {
  const { handleSession } = useAuth();
  const navigate = useNavigate();

  const [login, setLogin] = useState({
    email: "",
    password: "",
  });

  const [loading, setLoading] = useState(false);

  const handleOnChange = (event) => {
    const { name, value } = event.target;
    setLogin((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    setLoading(true);

    try {
      const response = await fetch(
        `${import.meta.env.VITE_API_URL}/api/auth/login`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            mail: login.email,
            password: login.password,
          }),
        }
      );

      const rawData = await response.text(); // 🔍 Leer la respuesta como texto primero
      let data;

      try {
        data = JSON.parse(rawData); // Intentar convertirlo a JSON
      } catch {
        data = rawData; // Si falla, dejarlo como texto
      }

      // console.log("🔍 Response Status:", response.status); // Debug
      // console.log("🔍 Data response:", data); // Debug

      if (!response.ok) {
        if (
          response.status === 401 &&
          typeof data === "string" &&
          data.includes("username or password is incorrect")
        ) {
          throw new Error("Datos incorrectos.\nPrueba nuevamente");
        } else if (response.status === 500) {
          throw new Error("Error en el servidor.\nIntenta más tarde");
        } else {
          throw new Error("Error desconocido en la autenticación.");
        }
      }

      // ✅ Si la autenticación es exitosa
      handleSession({
        ...login,
        token: data.token,
      });

      toast.success("Inicio de sesión exitoso", {
        position: "bottom-right",
        autoClose: 3000,
        hideProgressBar: false,
        closeOnClick: true,
        pauseOnFocusLoss: true,
        draggable: true,
        pauseOnHover: true,
        theme: "dark",
        newestOnTop: true,
      });

      navigate("/profile");
    } catch (err) {
      console.error("❌ Error en el login:", err.message);

      toast.error(err.message, {
        position: "bottom-right",
        autoClose: 5000,
        hideProgressBar: false,
        closeOnClick: true,
        pauseOnFocusLoss: true,
        draggable: true,
        pauseOnHover: true,
        theme: "dark",
        newestOnTop: true,
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label
          htmlFor="email"
          className="block text-sm font-medium text-gray-700"
        >
          Usuario - Para test usa: donero (cliente) / kevinryan (admin)
        </label>
        <input
          onChange={handleOnChange}
          type="text"
          id="email"
          name="email"
          value={login.email}
          className="mt-1 p-2 w-full border rounded-md focus:border-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-300 transition-colors duration-300"
          required
        />
      </div>
      <div>
        <label
          htmlFor="password"
          className="block text-sm font-medium text-gray-700"
        >
          Password (ewedon / kev02937@)
        </label>
        <input
          onChange={handleOnChange}
          type="password"
          id="password"
          name="password"
          value={login.password}
          className="mt-1 p-2 w-full border rounded-md focus:border-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-300 transition-colors duration-300"
          required
        />
      </div>
      <div>
        <button
          type="submit"
          disabled={loading}
          className="w-full bg-black text-white p-2 rounded-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-900 transition-colors duration-300"
        >
          {loading ? "Ingresando..." : "Ingresa"}
        </button>
      </div>
    </form>
  );
};

---
---
 // src/components/Marques.jsx

// src/components/Marques.jsx

import { Link } from "react-router-dom";

export const Marques = () => {
  return (
    <Link to="/auth/register" className="block w-full">
      <section className="bg-[#F5E1A4] text-[#262011] w-full">
        {/* Marquesina */}
        <div className="text-center text-sm bg-[#262011] text-[#F5E1A4] p-2 w-full font-bold">
          <p>
            🔥 ¡Oferta especial por tiempo limitado! Regístrate y obtén un 10%
            de descuento 🔥
          </p>
        </div>
      </section>
    </Link>
  );
};

---
---
 // src/components/ProductForm.jsx


---
---
 // src/components/RegisterForm.jsx

// src/components/RegisterForm.jsx

import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { toast } from "react-toastify";

export const RegisterForm = () => {
  const navigate = useNavigate();

  // Se definen los campos requeridos según el endpoint: name, lastname, mail, password.
  const [userData, setUserData] = useState({
    firstName: "",
    lastName: "",
    mail: "",
    password: "",
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Maneja los cambios en los inputs y actualiza el estado
  const handleOnChange = (event) => {
    const { name, value } = event.target;
    setUserData((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  // Construye el payload que se enviará al backend
  const buildPayload = () => {
    return {
      name: userData.firstName,
      lastname: userData.lastName,
      mail: userData.mail,
      password: userData.password,
    };
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    setLoading(true);
    setError(null);

    const payload = buildPayload();

    try {
      // Usamos la variable de entorno VITE_API_URL definida en el .env local.
      const API_URL = import.meta.env.VITE_API_URL;
      const response = await fetch(`${API_URL}/api/auth/register`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      });

      // Revisamos si la respuesta no fue exitosa.
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Error en el registro");
      }

      // Si el registro es exitoso...
      // Mostramos un toast de éxito y redirigimos al login.
      toast.success("Registro exitoso. Ahora puedes iniciar sesión.", {
        position: "bottom-right",
        autoClose: 3000,
        theme: "dark",
      });
      navigate("/auth/login");
    } catch (error) {
      console.error("Registro fallido:", error);
      setError(
        error.message || "Hubo un problema con el registro. Intenta de nuevo."
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label
          htmlFor="firstName"
          className="block text-sm font-medium text-gray-700"
        >
          Nombre
        </label>
        <input
          type="text"
          id="firstName"
          name="firstName"
          value={userData.firstName}
          onChange={handleOnChange}
          className="mt-1 p-2 w-full border rounded-md focus:border-gray-200
                     focus:outline-none focus:ring-2 focus:ring-offset-2
                     focus:ring-gray-300 transition-colors duration-300"
          required
        />
      </div>

      <div>
        <label
          htmlFor="lastName"
          className="block text-sm font-medium text-gray-700"
        >
          Apellido
        </label>
        <input
          type="text"
          id="lastName"
          name="lastName"
          value={userData.lastName}
          onChange={handleOnChange}
          className="mt-1 p-2 w-full border rounded-md focus:border-gray-200
                     focus:outline-none focus:ring-2 focus:ring-offset-2
                     focus:ring-gray-300 transition-colors duration-300"
          required
        />
      </div>

      <div>
        <label
          htmlFor="mail"
          className="block text-sm font-medium text-gray-700"
        >
          Email
        </label>
        <input
          type="email"
          id="mail"
          name="mail"
          value={userData.mail}
          onChange={handleOnChange}
          className="mt-1 p-2 w-full border rounded-md focus:border-gray-200
                     focus:outline-none focus:ring-2 focus:ring-offset-2
                     focus:ring-gray-300 transition-colors duration-300"
          required
        />
      </div>

      <div>
        <label
          htmlFor="password"
          className="block text-sm font-medium text-gray-700"
        >
          Password
        </label>
        <input
          type="password"
          id="password"
          name="password"
          value={userData.password}
          onChange={handleOnChange}
          className="mt-1 p-2 w-full border rounded-md focus:border-gray-200
                     focus:outline-none focus:ring-2 focus:ring-offset-2
                     focus:ring-gray-300 transition-colors duration-300"
          required
        />
      </div>

      {error && <div className="text-red-500 text-sm">{error}</div>}

      <div>
        <button
          type="submit"
          disabled={loading}
          className="w-full bg-black text-white p-2 rounded-md
                     hover:bg-gray-800 focus:outline-none focus:ring-2
                     focus:ring-offset-2 focus:ring-gray-900
                     transition-colors duration-300"
        >
          {loading ? "Registrando..." : "Regístrate"}
        </button>
      </div>
    </form>
  );
};

---
---
 // src/components/SearchBar.jsx

// src/components/SearchBar.jsx
import { useState, useEffect, useRef } from "react";
import { useProducts } from "../hooks/useProducts"; // Obtiene productos desde la API del sitio
import { useNavigate, useLocation } from "react-router-dom";

export const HeaderSearch = () => {
  const { products } = useProducts(); // Los productos vienen desde el backend
  const navigate = useNavigate();
  const location = useLocation();
  const [searchValue, setSearchValue] = useState("");
  const [searchPlaceholder, setSearchPlaceholder] = useState(
    "🔎 Buscar productos..."
  );
  const [suggestions, setSuggestions] = useState([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const containerRef = useRef(null);
  const inputRef = useRef(null);

  // Resetea la barra de búsqueda cada vez que cambie la ubicación
  useEffect(() => {
    setSearchValue("");
    setShowSuggestions(false);
    setSearchPlaceholder("🔎 Buscar productos...");
  }, [location]);

  // Actualiza las sugerencias en base al valor de búsqueda
  useEffect(() => {
    if (searchValue.trim() === "") {
      setSuggestions([]);
    } else {
      const lowerQuery = searchValue.toLowerCase();
      // Filtra usando la propiedad 'product' ya que es el nombre del producto en la BD
      const filtered = products.filter((product) =>
        product.product.toLowerCase().includes(lowerQuery)
      );
      setSuggestions(filtered);
    }
  }, [searchValue, products]);

  // Navega a la página de detalle del producto
  const handleSuggestionClick = (productId) => {
    navigate(`/product/${productId}`);
    setSearchValue("");
    setShowSuggestions(false);
    setSearchPlaceholder("🔎 Buscar productos...");
  };

  // Navega a la vista de catálogo aplicando el parámetro de búsqueda
  const handleViewCatalog = () => {
    navigate(`/catalog?search=${encodeURIComponent(searchValue)}`);
    setShowSuggestions(false);
  };

  // Al presionar Enter se navega al catálogo
  const handleKeyDown = (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      handleViewCatalog();
      if (inputRef.current) {
        inputRef.current.blur();
      }
    }
  };

  return (
    <div
      className={`relative bg-white p-2 border border-black w-80 h-12 flex justify-center ${
        showSuggestions ? "rounded-t-lg" : "rounded-lg"
      }`}
      ref={containerRef}
    >
      <input
        ref={inputRef}
        type="text"
        value={searchValue}
        placeholder={searchPlaceholder}
        onChange={(e) => {
          setSearchValue(e.target.value);
          setShowSuggestions(true);
        }}
        onFocus={() => {
          if (searchValue.trim() === "") {
            setSearchPlaceholder("");
          }
          if (searchValue.trim() !== "") {
            setShowSuggestions(true);
          }
        }}
        onBlur={() => {
          setTimeout(() => {
            setShowSuggestions(false);
          }, 150);
          if (searchValue.trim() === "") {
            setSearchPlaceholder("🔎 Buscar productos...");
          }
        }}
        onKeyDown={handleKeyDown}
        className="w-full text-center text-black border-none focus:outline-none focus:ring-0 bg-transparent p-2"
      />

      {showSuggestions &&
        searchValue.trim() !== "" &&
        suggestions.length > 0 && (
          <ul className="absolute z-10 left-0 right-0 top-full bg-white border border-black rounded-b-md max-h-60 overflow-y-auto">
            {suggestions.slice(0, 4).map((product) => (
              <li
                key={product.id}
                onMouseDown={() => handleSuggestionClick(product.id)}
                className="cursor-pointer p-2 hover:bg-[#F5E1A4] border-b border-gray-300 last:border-0 truncate whitespace-nowrap overflow-hidden"
              >
                {product.product}
              </li>
            ))}
            <li
              onMouseDown={handleViewCatalog}
              className="cursor-pointer p-2 text-center font-semibold text-[#262011] bg-gray-200 hover:bg-[#F5E1A4] truncate whitespace-nowrap overflow-hidden"
            >
              Ver coincidencias en Catálogo
            </li>
          </ul>
        )}
    </div>
  );
};

---
---
 // src/context/AuthProvider.jsx

// src/context/AuthProvider.jsx

import { createContext, useEffect, useState } from "react";
import { useStorage } from "../hooks/useStorage";

// Creamos el contexto de autenticación
export const AuthContext = createContext();

// Función para decodificar el token JWT (solo el payload)
const decodeToken = (token) => {
  try {
    const payload = token.split(".")[1];
    return JSON.parse(atob(payload));
  } catch (error) {
    console.error("Error decoding token", error);
    return {};
  }
};

export const AuthProvider = ({ children }) => {
  const { handleSetStorageSession, handleGetStorageSession } = useStorage();
  const [session, setSession] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  // Al guardar la sesión, decodificamos el token para extraer datos (por ejemplo, role)
  const handleSession = (newSession) => {
    if (newSession.token) {
      const decoded = decodeToken(newSession.token);
      newSession = { ...newSession, ...decoded };
    }
    setSession(newSession);
    handleSetStorageSession(newSession);
  };

  const logout = () => {
    setSession(null);
    localStorage.removeItem("USER_SESSION");
  };

  useEffect(() => {
    const storedSession = handleGetStorageSession();
    if (storedSession) {
      try {
        const parsedSession = JSON.parse(storedSession);
        setSession(parsedSession);
      } catch (error) {
        console.error("Error parsing stored session:", error);
        setSession(null);
      }
    }
    setIsLoading(false);
  }, [handleGetStorageSession]);

  return (
    <AuthContext.Provider value={{ session, isLoading, handleSession, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

---
---
 // src/context/CartProvider.jsx

// src/context/CartProvider.jsx

import { createContext, useState } from "react";

export const CartContext = createContext();

export const CartProvider = ({ children }) => {
  const [cart, setCart] = useState([]);

  return (
    <CartContext.Provider value={{ cart, setCart }}>
      {children}
    </CartContext.Provider>
  );
};

---
---
 // src/context/ProductProvider.jsx

// src/context/ProductProvider.jsx

import { createContext, useState, useEffect } from "react";
import { getProducts } from "../helpers/getProductData.helper"; // Importar la API de productos

export const ProductContext = createContext();

export const ProductProvider = ({ children }) => {
  const [products, setProducts] = useState([]);

  // Cargar productos
  useEffect(() => {
    const fetchProducts = async () => {
      try {
        const productData = await getProducts();
        setProducts(productData); // Guardar productos en el estado global
      } catch (error) {
        console.error("Error cargando productos:", error);
      }
    };

    fetchProducts();
  }, []);

  return (
    <ProductContext.Provider value={{ products, setProducts }}>
      {children}
    </ProductContext.Provider>
  );
};

---
---
 // src/data/images.json

{
  "images": [
    "babka_001.jpg",
    "babka_002.jpg",
    "babka_003.jpg",
    "batido_000.jpg",
    "batido_001.jpg",
    "batido_002.jpg",
    "brioche_000.jpg",
    "brioche_001.jpg",
    "brioche_002.jpg",
    "brioche_003.jpg",
    "brioche_004.jpg",
    "brioche_005.jpg",
    "brioche_006.jpg",
    "ciabatta_004.jpg",
    "ciabatta_005.jpg",
    "focaccia_000.jpg",
    "galleta_000.jpg",
    "galleta_001.jpg",
    "galleta_002.jpg",
    "galleta_003.jpg",
    "galleta_004.jpg",
    "galleta_005.jpg",
    "galleta_006.jpg",
    "galleta_007.jpg",
    "hogaza_000.jpg",
    "hogaza_001.jpg",
    "hogaza_002.jpg",
    "hogaza_003.jpg",
    "hogaza_004.jpg",
    "hogaza_005.jpg",
    "hogaza_006.jpg",
    "hogaza_007.jpg",
    "hogaza_008.jpg",
    "hogaza_009.jpg",
    "hogaza_010.jpg",
    "hogaza_011.jpg",
    "hogaza_012.jpg",
    "hogaza_013.jpg",
    "hogaza_014.jpg",
    "hogaza_nuez_000.jpg",
    "hogaza_nuez_001.jpg",
    "hogaza_nuez_002.jpg",
    "horno_000.jpg",
    "horno_001.jpg",
    "insumos_000.jpg",
    "insumos_001.jpg",
    "kuchen_000.jpg",
    "lemon_pie_000.jpg",
    "lemon_pie_001.jpg",
    "lemon_pie_002.jpg",
    "marca_000.jpg",
    "marca_001.jpg",
    "marca_002.jpg",
    "marca_003.jpg",
    "marca_004.jpg",
    "marca_008.jpg",
    "masa_000.jpg",
    "masa_001.jpg",
    "masa_002.jpg",
    "masa_003.jpg",
    "masa_004.jpg",
    "masa_madre_000.jpg",
    "masa_madre_001.jpg",
    "miti_mota_000.jpg",
    "miti_mota_001.jpg",
    "molde_000.jpg",
    "molde_centeno_000.jpg",
    "molde_integral_000.jpg",
    "molde_integral_001.jpg",
    "molde_integral_002.jpg",
    "molde_integral_003.jpg",
    "molde_integral_004.jpg",
    "molde_multisemilla_000.jpg",
    "molde_multisemilla_001.jpg",
    "prepizza_000.jpg",
    "prepizza_001.jpg",
    "prepizza_002.jpg",
    "snicker_pie_000.jpg"
  ]
}

---
---
 // src/data/promo.json

{
  "promo": ["promo.mp4"],
  "login": ["login.mp4"],
  "register": ["register.mp4"]
}

---
---
 // src/data/slides.json

{
  "slides": [
    {
      "image": "slide-001.jpg",
      "alt": "Brioche"
    },
    {
      "image": "slide-002.jpg",
      "alt": "Galletas"
    },
    {
      "image": "slide-003.jpg",
      "alt": "Pre-Pizzas"
    },
    {
      "image": "slide-004.jpg",
      "alt": "Molde Integral"
    },
    {
      "image": "slide-005.jpg",
      "alt": "Brioche"
    }
  ]
}

---
---
 // src/data/userTest.json

{
  "users": [
    {
      "username": "kevinryan",
      "role": "admin"
    },
    {
      "username": "donero",
      "role": "customer"
    }
  ]
}

---
---
 // src/guard/AuthGuard.jsx

// src/guard/AuthGuard.jsx

import { useAuth } from "../hooks/useAuth";
import { Navigate, Outlet } from "react-router-dom";

export const AuthGuard = ({ children, isAllow, redirectTo = "/login" }) => {
  const { isLoading } = useAuth();

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (!isAllow) {
    return <Navigate to={redirectTo} replace />;
  }

  return children ? children : <Outlet />;
};

---
---
 // src/helpers/api.jsx

export const apiFetch = async (endpoint, options = {}) => {
  const API_BASE = import.meta.env.VITE_API_URL;
  // Si necesitas enviar el token (por ejemplo, obteniéndolo de algún estado o storage):
  const token = localStorage.getItem("USER_TOKEN"); // o extraerlo de la sesión
  const headers = {
    "Content-Type": "application/json",
    ...(token ? { Authorization: `Bearer ${token}` } : {}),
    ...options.headers,
  };

  const response = await fetch(`${API_BASE}/api${endpoint}`, {
    ...options,
    headers,
  });
  if (!response.ok) {
    // Manejo de errores: puedes personalizar el throw según el status
    const errorData = await response.json();
    throw new Error(errorData.message || "Error en la API");
  }
  return response.json();
};

---
---
 // src/helpers/cloudinaryUpload.jsx

// backend/src/helpers/cloudinaryHelper.js
const cloudinary = require("../../cloudinaryConfig"); // Ajusta la ruta si es necesario

/**
 * Sube un archivo a Cloudinary.
 * @param {Buffer} fileBuffer - El buffer del archivo.
 * @param {string} mimetype - El tipo MIME del archivo.
 * @param {string} folder - (Opcional) Carpeta destino en Cloudinary.
 * @returns {Promise<Object>} - Resultado de la subida (incluye secure_url y public_id).
 */
const uploadImage = (fileBuffer, mimetype, folder = "productos") => {
  return new Promise((resolve, reject) => {
    const uploadStream = cloudinary.uploader.upload_stream(
      { folder },
      (error, result) => {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      }
    );
    uploadStream.end(fileBuffer);
  });
};

/**
 * Elimina una imagen de Cloudinary.
 * @param {string} publicId - El public_id de la imagen a eliminar.
 * @returns {Promise<Object>} - Resultado de la eliminación.
 */
const deleteImage = async (publicId) => {
  try {
    const result = await cloudinary.uploader.destroy(publicId);
    return result;
  } catch (error) {
    throw error;
  }
};

module.exports = { uploadImage, deleteImage };

---
---
 // src/helpers/fakeStoreAPI.jsx

export const getCategories = async () => {
  try {
    const response = await fetch(
      "https://fakestoreapi.com/products/categories"
    );
    if (!response.ok) {
      throw new Error("Error al obtener categorías");
    }
    return await response.json();
  } catch (error) {
    console.error(error);
    return [];
  }
};

export const getProducts = async () => {
  try {
    const response = await fetch("https://fakestoreapi.com/products");
    if (!response.ok) throw new Error("Error fetching products");
    return await response.json();
  } catch (error) {
    console.error("Error:", error);
    return [];
  }
};

---
---
 // src/helpers/getProductData.helper.js

// src/helpers/getProductData.helper.js
export const getProducts = async (query = "") => {
  try {
    // Asegurarse de que si hay query, incluya el símbolo de interrogación (la URL ya lo incluye en location.search)
    const url = `${import.meta.env.VITE_API_URL}/api/products${query}`;
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error("Error al obtener productos");
    }
    return await response.json();
  } catch (error) {
    console.error("Error al obtener productos:", error);
    return [];
  }
};

export const getCategories = async () => {
  try {
    const response = await fetch(
      `${import.meta.env.VITE_API_URL}/api/categories`
    );
    if (!response.ok) {
      throw new Error("Error al obtener categorías");
    }
    return await response.json();
  } catch (error) {
    console.error("Error al obtener categorías:", error);
    return [];
  }
};

---
---
 // src/helpers/roles.jsx

// src/helpers/roles.jsx

export const roles = {
  admin: "admin",
  guest: "guest",
  customer: "customer",
  developer: "developer",
};

---
---
 // src/hooks/useAuth.jsx

// src/hooks/useAuth.jsx

import { useContext } from "react";
import { AuthContext } from "../context/AuthProvider";

export const useAuth = () => {
  const { session, isLoading, handleSession, logout } = useContext(AuthContext);

  return {
    session,
    isLoading,
    handleSession,
    logout,
  };
};

---
---
 // src/hooks/useCart.jsx

// src/hooks/useCart.jsx

import { useContext, useCallback } from "react";
import { CartContext } from "../context/CartProvider";

export const useCart = () => {
  const { cart, setCart } = useContext(CartContext);

  const addToCart = (product, quantity) => {
    setCart((prevCart) => {
      const existingProduct = prevCart.find((item) => item.id === product.id);
      if (existingProduct) {
        return prevCart.map((item) =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + quantity }
            : item
        );
      }
      return [...prevCart, { ...product, quantity }];
    });
  };

  const updateQuantity = (id, quantity) => {
    if (quantity < 1) return; // No permitir valores negativos
    setCart((prevCart) =>
      prevCart.map((item) => (item.id === id ? { ...item, quantity } : item))
    );
  };

  const removeFromCart = (id) => {
    setCart((prevCart) => prevCart.filter((item) => item.id !== id));
  };

  const clearCart = useCallback(() => {
    setCart([]);
  }, [setCart]);

  return {
    cart,
    addToCart,
    updateQuantity,
    removeFromCart,
    clearCart,
  };
};

---
---
 // src/hooks/useEncrypt.jsx

// src/hooks/useEncrypt.jsx

import CryptoJs from "crypto-js";
import { useState } from "react";
const { VITE_CRYPTOJS_SECRET } = import.meta.env;

export const useEncrypt = () => {
  const [encrypted, setEncrypted] = useState(null);
  const [decrypted, setDecrypted] = useState(null);

  const handleEncrypt = (data) => {
    const encryptedData = CryptoJs.AES.encrypt(
      JSON.stringify(data),
      String(VITE_CRYPTOJS_SECRET)
    ).toString();

    setEncrypted(encryptedData);
  };

  const handleDecrypt = (encryptedData) => {
    const decryptedData = CryptoJs.AES.decrypt(
      encryptedData,
      String(VITE_CRYPTOJS_SECRET)
    ).toString(CryptoJs.enc.Utf8);

    setDecrypted(decryptedData);
  };

  return {
    encrypted,
    decrypted,
    handleEncrypt,
    handleDecrypt,
  };
};

---
---
 // src/hooks/useProductImages.jsx

// src/hooks/useProductImages.js
import { useState, useRef } from "react";
import { toast } from "react-toastify";

export const useProductImages = (API_URL, session, editingProductId) => {
  // Estado para las imágenes: 4 slots (null, File o { secure_url, public_id })
  const [productImages, setProductImages] = useState([null, null, null, null]);

  // Refs para los inputs file (4 slots)
  const fileInputsRef = useRef([]);
  if (fileInputsRef.current.length !== 4) {
    fileInputsRef.current = Array(4)
      .fill(null)
      .map((_, i) => fileInputsRef.current[i] || { current: null });
  }

  // Forzar el click en el input file del slot indicado
  const handleFileSelect = (slotIndex) => {
    if (
      fileInputsRef.current[slotIndex] &&
      fileInputsRef.current[slotIndex].current
    ) {
      fileInputsRef.current[slotIndex].current.click();
    }
  };

  // Función para subir un archivo a Cloudinary
  const handleUploadFile = async (file, slotIndex, productId) => {
    try {
      const formDataObj = new FormData();
      formDataObj.append("image", file);
      formDataObj.append("productId", productId);
      const response = await fetch(`${API_URL}/api/upload`, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${session?.token}`,
        },
        body: formDataObj,
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error || "Error al subir imagen");
      }
      setProductImages((prev) => {
        const newArr = [...prev];
        newArr[slotIndex] = {
          secure_url: data.secure_url,
          public_id: data.public_id,
        };
        return newArr;
      });
      toast.success("Imagen cargada", { position: "bottom-right" });
    } catch (error) {
      toast.error(error.message, { position: "bottom-right" });
    }
  };

  // Función para manejar el cambio de archivo en un input del slot indicado
  const handleFileChange = (e, slotIndex) => {
    const file = e.target.files[0];
    if (file) {
      if (editingProductId) {
        // Si se está editando, sube inmediatamente usando el ID del producto
        handleUploadFile(file, slotIndex, editingProductId);
      } else {
        // Para nuevo producto, solo se guarda el objeto File para subirlo luego
        setProductImages((prev) => {
          const newArr = [...prev];
          newArr[slotIndex] = file;
          return newArr;
        });
        toast.info("Imagen seleccionada. Se subirá al guardar el producto.", {
          position: "bottom-right",
        });
      }
    }
  };

  // Función para eliminar la imagen en el slot indicado
  const handleDeleteImage = async (slotIndex) => {
    const image = productImages[slotIndex];
    if (!image) return;
    if (image.public_id) {
      try {
        const response = await fetch(`${API_URL}/api/upload`, {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${session?.token}`,
          },
          body: JSON.stringify({ public_id: image.public_id }),
        });
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || "Error al eliminar imagen");
        }
        toast.success("Imagen eliminada", { position: "bottom-right" });
      } catch (error) {
        toast.error(error.message, { position: "bottom-right" });
      }
    }
    setProductImages((prev) => {
      const newArr = [...prev];
      newArr[slotIndex] = null;
      return newArr;
    });
  };

  return {
    productImages,
    setProductImages,
    fileInputsRef,
    handleFileSelect,
    handleFileChange,
    handleDeleteImage,
  };
};

---
---
 // src/hooks/useProducts.jsx

// src/hooks/useProducts.jsx
import { useContext, useEffect, useState } from "react";
import { ProductContext } from "../context/ProductProvider";
import { getProducts } from "../helpers/getProductData.helper";

export const useProducts = (query = "") => {
  const { products, setProducts } = useContext(ProductContext);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Se vuelve a hacer fetch cada vez que cambie la query (por ejemplo, ?category=...)
    setLoading(true);
    getProducts(query)
      .then((data) => {
        setProducts(data);
        setLoading(false);
      })
      .catch((err) => {
        console.error("Error fetching products:", err);
        setLoading(false);
      });
  }, [query, setProducts]);

  return { products, loading };
};

---
---
 // src/hooks/useStorage.jsx

// src/hooks/useStorage.jsx

import { useEffect } from "react";
import { useEncrypt } from "./useEncrypt";

export const useStorage = () => {
  const { encrypted, decrypted, handleEncrypt, handleDecrypt } = useEncrypt();

  const handleSetStorageSession = (session) => {
    handleEncrypt(session);
  };

  const handleGetStorageSession = () => {
    const encryptedSession = localStorage.getItem("USER_SESSION");

    if (encryptedSession) {
      handleDecrypt(encryptedSession);
    }
  };

  useEffect(() => {
    if (encrypted) {
      localStorage.setItem("USER_SESSION", encrypted);
    }
  }, [encrypted]);

  return {
    handleSetStorageSession,
    handleGetStorageSession,
    decrypted,
  };
};

---
---
 // src/index.css

@import url("https://fonts.googleapis.com/css2?family=Barlow:wght@400;500;600;700&display=swap");

@import "tailwindcss";

/* Establece Barlow como fuente predeterminada para todo el sitio */
body {
  font-family: "Barlow", sans-serif;
}
---
---
 // src/layouts/AdminLayout.jsx

// src/layouts/AdminLayout.jsx

import {
  UserOutlined,
  VideoCameraOutlined,
  UploadOutlined,
  MenuUnfoldOutlined,
  MenuFoldOutlined,
} from "@ant-design/icons";
import { Button, Layout, Menu, theme } from "antd";
import { useState } from "react";
import { Outlet } from "react-router-dom";

const { Header, Sider, Content } = Layout;

export const AdminLayout = () => {
  const [collapsed, setCollapsed] = useState(false);

  const {
    token: { colorBgContainer, borderRadiusLG },
  } = theme.useToken();

  return (
    <Layout className="min-h-screen">
      <Sider trigger={null} collapsible collapsed={collapsed}>
        <div className="demo-logo-vertical" />
        <Menu
          theme="dark"
          mode="inline"
          defaultSelectedKeys={["1"]}
          items={[
            {
              key: "1",
              icon: <UserOutlined />,
              label: "nav 1",
            },
            {
              key: "2",
              icon: <VideoCameraOutlined />,
              label: "nav 2",
            },
            {
              key: "3",
              icon: <UploadOutlined />,
              label: "nav 3",
            },
          ]}
        />
      </Sider>
      <Layout>
        <Header
          style={{
            padding: 0,
            background: colorBgContainer,
          }}
        >
          <Button
            type="text"
            icon={collapsed ? <MenuUnfoldOutlined /> : <MenuFoldOutlined />}
            onClick={() => setCollapsed(!collapsed)}
            style={{
              fontSize: "16px",
              width: 64,
              height: 64,
            }}
          />
        </Header>
        <Content
          style={{
            margin: "24px 16px",
            padding: 24,
            minHeight: 280,
            background: colorBgContainer,
            borderRadius: borderRadiusLG,
          }}
        >
          <Outlet />
        </Content>
      </Layout>
    </Layout>
  );
};

---
---
 // src/layouts/AuthLayout.jsx

// src/layouts/AuthLayout.jsx

import { Outlet } from "react-router-dom";
import { Header } from "../components/Header";
import { Footer } from "../components/Footer";
import { Credits } from "../components/Credits";

export const AuthLayout = () => {
  return (
    <div className="flex flex-col min-h-screen">
      <Header />
      <main className="flex-grow container mx-auto p-4 flex items-center justify-center">
        <Outlet />
      </main>
      <Footer />
      <Credits />
    </div>
  );
};

---
---
 // src/layouts/MainLayout.jsx

// src/layouts/MainLayout.jsx

import { Outlet } from "react-router-dom";
import { Marques } from "../components/Marques";
import { Header } from "../components/Header";
import { Footer } from "../components/Footer";
import { Credits } from "../components/Credits";
import { useAuth } from "../hooks/useAuth";

export const MainLayout = () => {
  const { session } = useAuth(); // Obtener sesión
  return (
    <div className="flex flex-col min-h-screen">
      {/* Mostrar Marques solo si no hay sesión iniciada */}
      {!session?.token && <Marques />}
      <Header />
      <main className="flex-grow container mx-auto p-4">
        <Outlet /> {/* Aquí se renderizan las páginas */}
      </main>
      <Footer />
      <Credits />
    </div>
  );
};

---
---
 // src/main.jsx

import ReactDOM from "react-dom/client";
import App from "./App.jsx";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")).render(<App />);

---
---
 // src/pages/CartPage.jsx

// src/pages/CartPage.jsx

import { Button, Card, List, Space, Typography, Image, Input } from "antd";
import { useState } from "react";
import { useCart } from "../hooks/useCart";
import { toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import { useNavigate } from "react-router-dom";

const { Text, Title } = Typography;

export const CartPage = () => {
  const { cart, updateQuantity, removeFromCart } = useCart();
  const [inputErrors, setInputErrors] = useState({}); // Manejo de errores por producto
  const navigate = useNavigate();

  const handleQuantityChange = (id, value) => {
    if (value === "" || isNaN(value)) return; // Permitir edición vacía sin error
    const numValue = parseInt(value, 10);

    if (numValue > 0) {
      updateQuantity(id, numValue);
      setInputErrors((prev) => ({ ...prev, [id]: false })); // Quitar error si es válido
    } else {
      setInputErrors((prev) => ({ ...prev, [id]: true })); // Marcar error
      toast.warning("Valor debe ser mayor que 0", {
        position: "bottom-right",
        autoClose: 5000,
        hideProgressBar: false,
        closeOnClick: true,
        pauseOnFocusLoss: true,
        draggable: true,
        pauseOnHover: true,
        theme: "dark",
        newestOnTop: true,
      });
    }
  };

  const handleRemoveFromCart = (id) => {
    removeFromCart(id);
    toast.info("Producto eliminado", {
      position: "bottom-right",
      autoClose: 3000,
      hideProgressBar: false,
      closeOnClick: true,
      pauseOnFocusLoss: true,
      draggable: true,
      pauseOnHover: true,
      theme: "dark",
      newestOnTop: true,
    });
  };

  const total = cart.reduce((acc, item) => acc + item.price * item.quantity, 0);

  return (
    <div style={{ padding: "24px", maxWidth: "800px", margin: "0 auto" }}>
      <Title level={2} style={{ marginBottom: "24px", textAlign: "center" }}>
        Tu Carrito
      </Title>

      <Card>
        {cart.length === 0 ? (
          <Text type="secondary">Tu carrito está vacío</Text>
        ) : (
          <List
            dataSource={cart}
            renderItem={(item) => (
              <List.Item>
                <div
                  style={{
                    display: "grid",
                    gridTemplateColumns: "2fr 4fr 2fr",
                    alignItems: "center",
                    width: "100%",
                    gap: "2rem",
                  }}
                >
                  {/* Miniatura de la imagen */}
                  <div style={{ display: "flex", justifyContent: "center" }}>
                    <Image
                      width={100}
                      src={item.image}
                      alt={item.title}
                      style={{ borderRadius: "5px" }}
                    />
                  </div>

                  {/* Información del producto */}
                  <Space direction="vertical" style={{ flex: 1 }}>
                    <Text strong>{item.title}</Text>
                    <Text>
                      Precio: ${item.price.toFixed(2)} x {item.quantity}
                    </Text>
                    <Text strong>
                      Total: ${(item.price * item.quantity).toFixed(2)}
                    </Text>
                  </Space>

                  {/* Controles de cantidad y eliminar */}
                  <div
                    style={{
                      display: "flex",
                      flexDirection: "column",
                      alignItems: "center",
                    }}
                  >
                    <div
                      style={{
                        display: "flex",
                        alignItems: "center",
                        gap: "0.5rem",
                      }}
                    >
                      <Button
                        onClick={() =>
                          updateQuantity(item.id, item.quantity - 1)
                        }
                        disabled={item.quantity <= 1}
                        style={{ border: "1px solid black" }}
                      >
                        -
                      </Button>
                      <Input
                        type="text"
                        value={item.quantity}
                        onChange={(e) =>
                          handleQuantityChange(item.id, e.target.value)
                        }
                        onBlur={(e) =>
                          handleQuantityChange(item.id, e.target.value)
                        } // Se actualiza inmediatamente
                        style={{
                          width: "50px",
                          textAlign: "center",
                          border: inputErrors[item.id]
                            ? "2px solid red"
                            : "1px solid black",
                        }}
                      />
                      <Button
                        onClick={() =>
                          updateQuantity(item.id, item.quantity + 1)
                        }
                        style={{ border: "1px solid black" }}
                      >
                        +
                      </Button>
                    </div>

                    <Button
                      type="link"
                      danger
                      onClick={() => handleRemoveFromCart(item.id)}
                      style={{ marginTop: "8px" }}
                    >
                      Eliminar
                    </Button>
                  </div>
                </div>
              </List.Item>
            )}
          />
        )}

        {/* Total del carrito */}
        <div style={{ marginTop: "24px", textAlign: "right" }}>
          <Title level={4}>Total: ${total.toFixed(2)}</Title>
          <Button
            type="primary"
            size="large"
            disabled={cart.length === 0}
            onClick={() => navigate("/checkout")}
            style={{
              backgroundColor: "#F5E1A4",
              color: "#262011",
              borderColor: "#F5E1A4",
            }}
          >
            Checkout
          </Button>
        </div>
      </Card>
    </div>
  );
};

---
---
 // src/pages/CatalogPage.jsx

// src/pages/CatalogPage.jsx
import { useState, useEffect } from "react";
import { Link, useLocation, useNavigate } from "react-router-dom";
import { Categories } from "../components/Categories";
import { useProducts } from "../hooks/useProducts";
import { FaHeart, FaTimes } from "react-icons/fa";
import { Dropdown, Menu, Button } from "antd";

export const CatalogPage = () => {
  const location = useLocation();
  const navigate = useNavigate();

  // Se le pasa location.search directamente para que el hook haga el fetch con esos parámetros
  const { products, loading } = useProducts(location.search);
  const [orderedProducts, setOrderedProducts] = useState([]);

  // Para la paginación
  const [currentPage, setCurrentPage] = useState(1);
  const itemsPerPage = 12;

  // Lógica de ordenamiento (se realiza en el frontend sobre los datos ya filtrados)
  useEffect(() => {
    // Al recibir productos del backend ya filtrados, se guardan en orderedProducts
    setOrderedProducts(products);
    setCurrentPage(1);
  }, [products]);

  const handleMenuClick = ({ key }) => {
    let sorted = [...orderedProducts];
    switch (key) {
      case "a-z":
        sorted.sort((a, b) => a.product.localeCompare(b.product));
        break;
      case "z-a":
        sorted.sort((a, b) => b.product.localeCompare(a.product));
        break;
      case "max-min":
        sorted.sort((a, b) => b.price - a.price);
        break;
      case "min-max":
        sorted.sort((a, b) => a.price - b.price);
        break;
      default:
        break;
    }
    setOrderedProducts(sorted);
    setCurrentPage(1);
  };

  const menu = (
    <Menu
      onClick={handleMenuClick}
      items={[
        { key: "a-z", label: "Ordenar de A a Z" },
        { key: "z-a", label: "Ordenar de Z a A" },
        { key: "max-min", label: "Ordenar de Mayor a Menor $" },
        { key: "min-max", label: "Ordenar de Menor a Mayor $" },
      ]}
    />
  );

  const totalPages = Math.ceil(orderedProducts.length / itemsPerPage);
  const displayedProducts = orderedProducts.slice(
    (currentPage - 1) * itemsPerPage,
    currentPage * itemsPerPage
  );

  // Para mostrar el filtro activo: se extrae la query (category o search)
  const params = new URLSearchParams(location.search);
  const categoryQuery = params.get("category");
  const searchQuery = params.get("search");

  let activeFilterTag = null;
  if (categoryQuery) {
    activeFilterTag = (
      <div
        className="flex items-center bg-[#262011] text-[#f5e1a4] px-3 py-1 rounded-full cursor-pointer"
        onClick={() => navigate("/catalog")}
      >
        Filtrando por: "{categoryQuery}" <FaTimes className="ml-1" />
      </div>
    );
  } else if (searchQuery) {
    activeFilterTag = (
      <div
        className="flex items-center bg-[#262011] text-[#f5e1a4] px-3 py-1 rounded-full cursor-pointer"
        onClick={() => navigate("/catalog")}
      >
        Filtrando por: "{searchQuery}" <FaTimes className="ml-1" />
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-4">
      <h2 className="text-3xl font-semibold">Catálogo de Productos</h2>
      {/* Muestra las categorías */}
      <Categories />

      {/* Resultados y Filtros */}
      <div className="flex justify-between items-center my-4">
        <div className="flex items-center gap-4">
          <div
            style={{
              backgroundColor: "#fff2d2",
              color: "#000",
              borderColor: "#ffcc00",
              fontSize: "16px",
              height: "3rem",
            }}
            className="bg-gray-300 p-2 border border-black rounded-md flex items-center"
          >
            Resultados: {orderedProducts.length} productos
          </div>
          {activeFilterTag}
        </div>
        <Dropdown overlay={menu} placement="bottomRight" trigger={["click"]}>
          <Button
            style={{
              backgroundColor: "#fff2d2",
              color: "#000",
              borderColor: "#ffcc00",
              fontSize: "16px",
              height: "3rem",
            }}
            className="bg-gray-300 p-2 border-black"
          >
            Ordenar
          </Button>
        </Dropdown>
      </div>

      {/* Grilla de Productos */}
      <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
        {loading ? (
          <p>Cargando productos...</p>
        ) : (
          displayedProducts.map((product) => (
            <Link
              key={product.id}
              to={`/product/${product.id}`}
              className="p-4 relative block hover:bg-gray-100 transition duration-200 rounded-2xl"
            >
              <FaHeart className="absolute top-2 right-2 text-black cursor-pointer" />
              <div className="bg-white w-full h-68 flex items-center justify-center border border-black p-4 rounded-2xl">
                <img
                  src={product.url_img}
                  alt={product.product}
                  className="h-full object-contain"
                />
              </div>
              <p className="mt-2 font-semibold">{product.product}</p>
              <p className="text-gray-600">${product.price}</p>
            </Link>
          ))
        )}
      </div>

      {/* Paginación */}
      <div className="flex justify-center mt-8 space-x-2">
        {[...Array(totalPages)].map((_, index) => (
          <button
            key={index}
            onClick={() => setCurrentPage(index + 1)}
            className={`px-4 py-2 border border-black ${
              currentPage === index + 1
                ? "bg-[#262011] text-[#f5e1a4]"
                : "bg-[#f5e1a4] text-[#262011]"
            }`}
          >
            {index + 1}
          </button>
        ))}
      </div>
    </div>
  );
};

---
---
 // src/pages/CheckoutPage.jsx

// src/pages/CheckoutPage.jsx

import { useState } from "react";
import { useCart } from "../hooks/useCart";
import { useAuth } from "../hooks/useAuth";
import { useNavigate } from "react-router-dom";

export const CheckoutPage = () => {
  const { cart } = useCart();
  const { session } = useAuth();
  const navigate = useNavigate();

  // Simula direcciones registradas
  const addresses = [
    { id: 1, label: "Casa - Calle Falsa 123, Caldera" },
    { id: 2, label: "Oficina - Av. Siempre Viva 456, Caldera" },
  ];
  const [selectedAddress, setSelectedAddress] = useState(addresses[0].id);

  // Datos de contacto (prefijados con datos de sesión si existen)
  const [contactData, setContactData] = useState({
    email: session?.email || "",
    phone: session?.phone || "",
  });

  // Método de pago
  const [paymentMethod, setPaymentMethod] = useState("credito");

  // Calcula el total del carrito
  const totalPayment = cart.reduce(
    (acc, item) => acc + item.price * item.quantity,
    0
  );

  const handleContactChange = (e) => {
    const { name, value } = e.target;
    setContactData((prev) => ({ ...prev, [name]: value }));
  };

  const handleRealizarCompra = async (e) => {
    e.preventDefault();
    const payload = {
      id_address: selectedAddress,
      order_delivery_date: "2025-03-01", // O generar dinámicamente la fecha
      order_address: "Dirección de ejemplo", // Reemplazar con el dato real
      order_city: "Ciudad de ejemplo",
      order_region: "Región de ejemplo",
      order_postal_code: "000000",
      order_phone: contactData.phone,
      items: cart.map((item) => ({
        productId: item.id,
        units: item.quantity,
        unit_price: item.price,
      })),
    };

    try {
      const response = await fetch(
        `${import.meta.env.VITE_API_URL}/api/orders/checkout`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        }
      );
      if (!response.ok) {
        // Manejar error según la respuesta (por ejemplo, stock insuficiente)
        throw new Error("Error al procesar la orden");
      }
      // Si la orden se procesa correctamente:
      navigate("/success");
    } catch (error) {
      console.error(error);
      // Mostrar error mediante toast o similar
    }
  };

  return (
    <div className="container mx-auto p-4">
      <h1 className="text-3xl font-bold mb-6 text-center">Checkout</h1>
      <div className="grid grid-cols-3 gap-4">
        {/* Panel Izquierdo (2/3) */}
        <div className="col-span-2 bg-white p-6 border border-gray-300 rounded-lg">
          {/* Información del usuario y dirección */}
          <div className="mb-6">
            <h2 className="text-xl font-bold mb-2">
              {session?.name ? `Hola, ${session.name}` : "Hola, Usuario"}
            </h2>
            <p className="mb-2 text-gray-700">Elige una dirección de envío:</p>
            <div className="space-y-2">
              {addresses.map((addr) => (
                <label
                  key={addr.id}
                  className="flex items-center space-x-2 cursor-pointer"
                >
                  <input
                    type="radio"
                    name="address"
                    value={addr.id}
                    checked={selectedAddress === addr.id}
                    onChange={() => setSelectedAddress(addr.id)}
                    className="form-radio"
                  />
                  <span>{addr.label}</span>
                </label>
              ))}
            </div>
          </div>

          {/* Datos de contacto */}
          <div className="mb-6">
            <h3 className="text-lg font-semibold mb-2">
              Confirma tus datos de contacto
            </h3>
            <div className="space-y-4">
              <div>
                <label htmlFor="email" className="block text-gray-700">
                  Email:
                </label>
                <input
                  type="email"
                  id="email"
                  name="email"
                  value={contactData.email}
                  onChange={handleContactChange}
                  placeholder="tu@correo.com"
                  className="mt-1 p-2 w-full border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-300"
                />
              </div>
              <div>
                <label htmlFor="phone" className="block text-gray-700">
                  Teléfono:
                </label>
                <input
                  type="text"
                  id="phone"
                  name="phone"
                  value={contactData.phone}
                  onChange={handleContactChange}
                  placeholder="Número de teléfono"
                  className="mt-1 p-2 w-full border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-300"
                />
              </div>
            </div>
          </div>

          {/* Mensaje de entrega */}
          <div className="mb-6">
            <p className="text-gray-600 italic">
              La entrega se realizará en 24 hrs hábiles.
            </p>
          </div>

          {/* Opciones de pago */}
          <div className="mb-6">
            <hr className="mb-4" />
            <h3 className="text-lg font-semibold mb-2">
              Elige tu método de pago
            </h3>
            <div className="flex items-center space-x-4">
              <label className="flex items-center space-x-1 cursor-pointer">
                <input
                  type="radio"
                  name="paymentMethod"
                  value="credito"
                  checked={paymentMethod === "credito"}
                  onChange={() => setPaymentMethod("credito")}
                  className="form-radio"
                />
                <span>Tarjeta Crédito</span>
              </label>
              <label className="flex items-center space-x-1 cursor-pointer">
                <input
                  type="radio"
                  name="paymentMethod"
                  value="debito"
                  checked={paymentMethod === "debito"}
                  onChange={() => setPaymentMethod("debito")}
                  className="form-radio"
                />
                <span>Tarjeta Débito</span>
              </label>
              <label className="flex items-center space-x-1 cursor-pointer">
                <input
                  type="radio"
                  name="paymentMethod"
                  value="transferencia"
                  checked={paymentMethod === "transferencia"}
                  onChange={() => setPaymentMethod("transferencia")}
                  className="form-radio"
                />
                <span>Transferencia electrónica</span>
              </label>
            </div>
          </div>
        </div>

        {/* Panel Derecho (1/3): Resumen del carrito */}
        <div className="col-span-1 bg-white p-6 border border-gray-300 rounded-lg flex flex-col">
          <h3 className="text-xl font-bold mb-4 text-center">
            Resumen de Compra
          </h3>
          <div className="flex-1 overflow-y-auto mb-4">
            {cart.length === 0 ? (
              <p>No hay productos en el carrito.</p>
            ) : (
              <ul className="space-y-4">
                {cart.map((item) => (
                  <li key={item.id} className="flex items-center space-x-2">
                    <img
                      src={item.image}
                      alt={item.title}
                      className="w-12 h-12 object-cover rounded"
                    />
                    <div className="flex-1">
                      <p className="text-sm font-semibold truncate">
                        {item.title}
                      </p>
                      <p className="text-xs text-gray-600">x {item.quantity}</p>
                    </div>
                    <div className="text-sm font-bold">
                      ${item.price.toFixed(2)}
                    </div>
                  </li>
                ))}
              </ul>
            )}
          </div>
          {/* Total de la compra */}
          <div className="border-t pt-4">
            <div className="flex justify-between items-center">
              <span className="font-semibold">Total:</span>
              <span className="font-bold">${totalPayment.toFixed(2)}</span>
            </div>
          </div>
          {/* Botón para realizar la compra */}
          <button
            onClick={handleRealizarCompra}
            className="mt-4 w-full bg-green-600 text-white p-3 rounded-md hover:bg-green-700 transition"
          >
            Realizar Compra
          </button>
        </div>
      </div>
    </div>
  );
};

---
---
 // src/pages/ContactPage.jsx

// src/pages/ContactPage.jsx

import { useState } from "react";
import { toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";

export const ContactPage = () => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    message: "",
  });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    // Validación simple
    if (!formData.name || !formData.email || !formData.message) {
      toast.error("Por favor, complete todos los campos", {
        position: "bottom-right",
        autoClose: 3000,
        theme: "dark",
      });
      return;
    }
    // Aquí podrías hacer la llamada a una API para enviar el mensaje
    // Simulamos el envío con un toast de éxito
    toast.success("Mensaje enviado correctamente", {
      position: "bottom-right",
      autoClose: 3000,
      theme: "dark",
    });
    // Reseteamos el formulario
    setFormData({
      name: "",
      email: "",
      message: "",
    });
  };

  return (
    <div className="max-h-screen  flex flex-col items-center justify-center bg-gray-100 p-4">
      <div className="bg-white p-8 rounded-lg shadow-lg max-w-md w-full">
        <h1 className="text-2xl font-bold mb-6 text-center">Contáctanos</h1>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="name" className="block text-gray-700">
              Nombre
            </label>
            <input
              type="text"
              id="name"
              name="name"
              value={formData.name}
              onChange={handleChange}
              placeholder="Tu nombre"
              className="mt-1 p-2 w-full border rounded-md focus:outline-none focus:ring-2 focus:ring-[#f5e1a4]"
            />
          </div>
          <div>
            <label htmlFor="email" className="block text-gray-700">
              Email
            </label>
            <input
              type="email"
              id="email"
              name="email"
              value={formData.email}
              onChange={handleChange}
              placeholder="tu@correo.com"
              className="mt-1 p-2 w-full border rounded-md focus:outline-none focus:ring-2 focus:ring-[#f5e1a4]"
            />
          </div>
          <div>
            <label htmlFor="message" className="block text-gray-700">
              Mensaje
            </label>
            <textarea
              id="message"
              name="message"
              value={formData.message}
              onChange={handleChange}
              placeholder="Escribe tu mensaje aquí..."
              rows="4"
              className="mt-1 p-2 w-full border rounded-md focus:outline-none focus:ring-2 focus:ring-[#f5e1a4]"
            ></textarea>
          </div>
          <div>
            <button
              type="submit"
              className="w-full bg-[#f5e1a4] text-[#262011] p-2 rounded-md hover:bg-[#262011] hover:text-white transition duration-300"
            >
              Enviar Mensaje
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

---
---
 // src/pages/DashboardPage.jsx

// src/pages/DashboardPage.jsx

export const DashboardPage = () => {
  return <h1>DashboardPage</h1>;
};

---
---
 // src/pages/HomePage.jsx

// src/pages/HomePage.jsx

import { useEffect, useState } from "react";

/* Import Swiper */
import { Swiper, SwiperSlide } from "swiper/react";
import { Autoplay, Navigation, Pagination } from "swiper/modules";
import "swiper/css";
import "swiper/css/navigation";
import "swiper/css/pagination";

/* Importar JSON Data */
import slidesData from "../data/slides.json";
import imagesData from "../data/images.json";
import promoData from "../data/promo.json";

/* Importar Categorías FakeAPI */
import { getCategories } from "../helpers/getProductData.helper"; // Simulación de datos
import { Categories } from "../components/Categories";

/* Importar Framer Motion */
import { motion } from "framer-motion";

export const HomePage = () => {
  /* Lógica randomización Productos BentoGrid*/
  const [images, setImages] = useState([]);
  useEffect(() => {
    const shuffled = imagesData.images.sort(() => 0.5 - Math.random());
    setImages(shuffled.slice(0, 9));
  }, []);

  /* Lógica Categorías */
  const [categories, setCategories] = useState([]);
  useEffect(() => {
    getCategories().then(setCategories);
  }, []);

  const promoVideo = new URL(
    `../assets/videos/${promoData.promo}`,
    import.meta.url
  ).href;

  return (
    <div className="min-h-screen flex flex-col">
      <main className="flex-1 container mx-auto px-4">
        {/* Galería / Slider */}
        <section className="my-8">
          <Swiper
            modules={[Autoplay, Navigation, Pagination]}
            spaceBetween={10}
            slidesPerView={1}
            navigation
            pagination={{ clickable: true }}
            autoplay={{ delay: 6000, disableOnInteraction: false }}
            speed={1800} /* Velocidad de la transición en milisegundos */
            loop={true} /* Hace que el carrusel sea infinito */
            loopAdditionalSlides={
              3
            } /* Carga más slides en el loop para evitar saltos */
            centeredSlides={
              false
            } /* Evita que una slide esté centrada al inicio */
            watchOverflow={true} /* Evita problemas cuando hay pocas slides */
            className="w-full h-[24rem] rounded-lg overflow-hidden"
            style={{ "--swiper-theme-color": "#262011" }}
          >
            {slidesData.slides.map((slide, index) => (
              <SwiperSlide key={index}>
                <img
                  src={
                    new URL(`../assets/images/${slide.image}`, import.meta.url)
                      .href
                  }
                  alt={slide.alt}
                  className="w-full h-full object-cover"
                />
              </SwiperSlide>
            ))}
          </Swiper>
        </section>

        {/* Categorías */}
        <h2 className="text-xl font-bold mb-4">Categorías</h2>
        <Categories />

        {/* Productos Bento Grid */}
        <h2 className="text-xl font-bold mb-4">Productos</h2>
        <section className="my-8 flex justify-center">
          <div
            className="grid gap-4 max-w-[120rem] max-h-[35rem]"
            style={{
              display: "grid",
              gridTemplateColumns: "repeat(4, 1fr)",
              gridTemplateRows: "repeat(3, 1fr)",
              gridTemplateAreas: `
            "a a b c"
            "d e e f"
            "g h i i"
          `,
              width: "120rem",
              height: "55rem",
            }}
          >
            {images.map((img, index) => (
              <motion.div
                key={index}
                className="rounded-lg overflow-hidden shadow-lg"
                style={{
                  gridArea: ["a", "b", "c", "d", "e", "f", "g", "h", "i"][
                    index
                  ],
                }}
                whileHover={{ scale: 1.05 }} // Aumenta un 5% el tamaño al hacer hover
                transition={{ duration: 1.2, ease: "easeInOut" }} // Animación lenta de 1.2s
              >
                <img
                  src={new URL(`../assets/images/${img}`, import.meta.url).href}
                  alt={`Producto ${index + 1}`}
                  className="w-full h-full object-cover rounded-lg"
                />
              </motion.div>
            ))}
          </div>
        </section>

        {/* Elígenos */}
        <section className="my-8 grid grid-cols-3 gap-8 items-center mt-20">
          <div className="col-span-2">
            <h2 className="text-xl font-bold mb-4">Elígenos</h2>
            <p>
              En el corazón del puerto de Caldera, nace &quot;La Pan
              Comido&quot;, una micro-panadería online que revoluciona la forma
              en que se disfruta del pan. Nuestro objetivo es ofrecer un pan
              sano y beneficioso para la salud, elaborado con masa madre y un
              proceso de fermentación que dura 17 horas, lo que le da un sabor y
              una textura únicos.
              <br />
              <br />
              Respetamos las recetas más tradicionales de pan, utilizando
              técnicas y ingredientes que han sido perfeccionados a lo largo de
              los años. Nuestros panes son el resultado de un proceso de
              elaboración que dura 2 días, desde el amasado hasta la salida del
              horno, lo que nos permite ofrecer un producto de alta calidad y
              sabor auténtico.
              <br />
              <br />
              Fundada en el año 2020, &quot;La Pan Comido&quot; se ha convertido
              en una referencia para aquellos que buscan un pan auténtico y
              delicioso. Nos enfocamos en ofrecer un producto que se asemeja a
              la tradición de las panaderías italianas, donde el pan es un arte
              y una pasión.
            </p>
          </div>
          <div className="w-full h-90">
            <video
              src={promoVideo}
              className="w-full h-full object-cover rounded-lg"
              autoPlay
              loop
              muted
            ></video>
          </div>
        </section>
      </main>
    </div>
  );
};

---
---
 // src/pages/LoginPage.jsx

// src/pages/LoginPage.jsx

import { LoginForm } from "../components/LoginForm";
import { Link } from "react-router-dom";
import { FcGoogle } from "react-icons/fc";
import { FaFacebook, FaApple } from "react-icons/fa";
import promoData from "../data/promo.json";

export const LoginPage = () => {
  const promoVideo = new URL(
    `../assets/videos/${promoData.login}`,
    import.meta.url
  ).href;

  return (
    <div
      className="flex items-center justify-center"
      // Altura total disponible luego de descontar header/footer:
      // Calc(100vh - (190px + 180px)) => 100vh - 370px
      // Esto mantiene un espacio fijo para header y footer.
      style={{ height: "calc(100vh - 400px)" }}
    >
      {/* 
        Contenedor con relación de aspecto 17/10 (~850/500). 
        max-w-[53.125rem] (850px/16) y max-h-[31.25rem] (500px/16) 
        para que no crezca más de lo deseado, pero sea responsive.
      */}
      <div className="aspect-[17/10] w-full max-w-[53.125rem] max-h-[31.25rem] overflow-hidden rounded-xl">
        <div className="flex w-full h-full">
          {/* Sección del video */}
          <div className="hidden lg:flex w-1/2 items-center justify-center bg-white text-black">
            <video
              src={promoVideo}
              autoPlay
              loop
              muted
              className="w-full h-full object-cover"
            />
          </div>

          {/* Sección del login */}
          <div className="w-full lg:w-1/2 bg-gray-100 flex items-center justify-center p-6">
            <div className="max-w-md w-full">
              <h1 className="text-3xl font-semibold mb-6 text-black text-center">
                Inicia Sesión
              </h1>
              {/* Botones de acceso rápido */}
              <div className="mt-4 flex flex-col lg:flex-row items-center justify-between gap-2">
                <button
                  type="button"
                  className="w-full flex justify-center items-center gap-2 bg-white text-sm text-gray-600 p-2 rounded-md 
                             hover:bg-gray-50 border border-gray-200 
                             focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-200 
                             transition-colors duration-300"
                >
                  <FcGoogle size={20} /> Google
                </button>

                <button
                  type="button"
                  className="w-full flex justify-center items-center gap-2 bg-white text-sm text-gray-600 p-2 rounded-md 
                             hover:bg-gray-50 border border-gray-200 
                             focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-200 
                             transition-colors duration-300"
                >
                  <FaFacebook size={20} className="text-blue-600" /> Facebook
                </button>

                <button
                  type="button"
                  className="w-full flex justify-center items-center gap-2 bg-white text-sm text-gray-600 p-2 rounded-md 
                             hover:bg-gray-50 border border-gray-200 
                             focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-200 
                             transition-colors duration-300"
                >
                  <FaApple size={20} className="text-black" /> Apple
                </button>
              </div>

              <div className="mt-4 text-sm text-gray-600 text-center">
                <p>o con tu correo</p>
              </div>

              <LoginForm />

              <div className="mt-4 text-sm text-gray-600 text-center">
                <p>
                  ¿Aún no tienes cuenta?{" "}
                  <Link
                    to="/auth/register"
                    className="text-black hover:underline"
                  >
                    Regístrate Aquí
                  </Link>
                </p>
                <p>
                  ¿Olvidaste tu clave?{" "}
                  <Link
                    to="/auth/reset-password"
                    className="text-black hover:underline"
                  >
                    Resetéala Aquí
                  </Link>
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

---
---
 // src/pages/Page404.jsx

// src/pages/Page404.jsx

import { Fragment } from "react";
import { Link } from "react-router-dom";
import pancito404 from "../assets/images/pancito_404.png";

export const Page404 = () => {
  return (
    <Fragment>
      <section className="h-screen w-full flex flex-col justify-center items-center bg-[#F5E1A4]">
        <img src={pancito404} alt="Pancito perdido" className="w-36" />
        <h1 className="text-9xl font-extrabold text-white tracking-widest">
          404
        </h1>
        <div className="bg-[#262011] px-2 text-white text-sm rounded mt-4">
          Nos perdimos en el horno
        </div>
        <Link
          to="/"
          className="mt-15 relative inline-block text-sm font-medium text-white group active:text-orange-500 focus:outline-none focus:ring"
        >
          <span className="absolute inset-0 transition-transform translate-x-0.5 translate-y-0.5 bg-[#262011] group-hover:translate-y-0 group-hover:translate-x-0 rounded-xl"></span>
          <span className="relative block px-8 py-3 bg-white border border-current rounded-xl text-[#262011]">
            Inicio
          </span>
        </Link>
      </section>
    </Fragment>
  );
};

---
---
 // src/pages/ProductPage.jsx

// src/pages/ProductPage.jsx
import { useState, useEffect } from "react";
import { useParams, Link } from "react-router-dom";
import { useCart } from "../hooks/useCart";
import { useAuth } from "../hooks/useAuth";
import { toast } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";

// Función para formatear precios en CLP
const formatCLP = (value) =>
  new Intl.NumberFormat("es-CL", {
    style: "currency",
    currency: "CLP",
    maximumFractionDigits: 0,
  }).format(value);

export const ProductPage = () => {
  const { id } = useParams();
  const [product, setProduct] = useState(null);
  // Estado para la imagen principal y las miniaturas (se mantienen en el orden original)
  const [mainImage, setMainImage] = useState("");
  const [thumbnails, setThumbnails] = useState([]);
  const [quantity, setQuantity] = useState(1);
  const [relatedProducts, setRelatedProducts] = useState([]);
  const { addToCart } = useCart();
  const { session } = useAuth();

  // Se obtiene el detalle del producto desde el backend
  useEffect(() => {
    const fetchProductDetail = async () => {
      try {
        const response = await fetch(
          `${import.meta.env.VITE_API_URL}/api/products/${id}`
        );
        if (!response.ok) {
          throw new Error("Error al obtener el producto");
        }
        const data = await response.json();
        setProduct(data);
        // La imagen principal será la primera de las imágenes (si existen)
        if (data.images && data.images.length > 0) {
          setMainImage(data.images[0]);
          // Clonamos el arreglo para las miniaturas
          setThumbnails([...data.images]);
        } else {
          // Si no hay imágenes, se puede usar un placeholder o algún campo alternativo
          setMainImage("");
          setThumbnails([]);
        }
        // Guardamos los productos relacionados (si los hay) y seleccionamos 4 al azar
        if (data.related && data.related.length > 0) {
          const shuffled = data.related.sort(() => 0.5 - Math.random());
          setRelatedProducts(shuffled.slice(0, 4));
        }
      } catch (error) {
        console.error(error);
        toast.error("Error al cargar el producto");
      }
    };

    fetchProductDetail();
  }, [id]);

  if (!product)
    return <p className="text-center mt-10">Cargando producto...</p>;

  // Manejo de cambio de cantidad, validando que no supere el stock disponible
  const handleQuantityChange = (newQuantity) => {
    if (newQuantity < 1) return;
    if (newQuantity > product.stock) {
      toast.warning("No hay más unidades disponibles para agregar", {
        position: "bottom-right",
        autoClose: 3000,
        theme: "dark",
      });
      return;
    }
    setQuantity(newQuantity);
  };

  // Agregar producto al carrito
  const handleAddToCart = () => {
    if (!session?.token) {
      toast.info("Para agregar al carro, inicia sesión", {
        position: "bottom-right",
        autoClose: 3000,
        theme: "dark",
      });
      return;
    }
    addToCart(product, quantity);
    toast.success("Producto agregado al carro", {
      position: "bottom-right",
      autoClose: 3000,
      theme: "dark",
    });
  };

  // Función para intercambiar la imagen principal con una miniatura
  const handleThumbnailClick = (index) => {
    // Se realiza un swap entre la imagen principal y la miniatura clickeada
    const newThumbnails = [...thumbnails];
    const temp = mainImage;
    newThumbnails[index] = temp;
    setMainImage(thumbnails[index]);
    setThumbnails(newThumbnails);
  };

  return (
    <div className="container mx-auto px-4 py-2">
      {/* Breadcrumb */}
      <div className="p-2 text-xl mb-12">
        <span>
          <Link to="/catalog" className="hover:underline">
            CATÁLOGO
          </Link>{" "}
          /{" "}
          {product.categories && product.categories.length > 0 && (
            <Link
              to={`/catalog?category=${encodeURIComponent(
                product.categories[0]
              )}`}
              className="hover:underline"
            >
              {product.categories[0].toUpperCase()}
            </Link>
          )}{" "}
          / <span>{product.product}</span>
        </span>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
        {/* Imagen principal con efecto zoom al hover */}
        <div className="flex justify-center">
          <div className="overflow-hidden border border-black p-4">
            <img
              src={mainImage}
              alt={product.product}
              className="transition-transform duration-300 ease-in-out transform hover:scale-105"
            />
          </div>
        </div>

        {/* Información del producto */}
        <div>
          <h1 className="text-3xl font-bold">{product.product}</h1>
          {/* Se muestra los ingredientes en lugar de description */}
          <p className="text-gray-600 mt-2">{product.ingredients}</p>

          {/* Mostrar stock: se valida con product.stock */}
          <p
            className={`mt-4 font-semibold ${
              product.stock > 0 ? "text-green-600" : "text-gray-600"
            }`}
          >
            {product.stock > 0 ? "En stock" : "Sin stock"}
          </p>

          {/* Precio formateado en CLP */}
          <p className="text-2xl font-bold mt-2">{formatCLP(product.price)}</p>

          {/* Controles de cantidad y botón agregar */}
          <div className="flex items-center mt-4 space-x-2">
            <button
              onClick={() => handleQuantityChange(quantity - 1)}
              className="bg-gray-300 px-3 py-1 border border-black"
            >
              -
            </button>
            <input
              type="text"
              value={quantity}
              onChange={(e) =>
                handleQuantityChange(parseInt(e.target.value) || 1)
              }
              onBlur={(e) =>
                handleQuantityChange(parseInt(e.target.value) || 1)
              }
              className="w-12 h-8 text-center border border-black"
            />
            <button
              onClick={() => handleQuantityChange(quantity + 1)}
              className="bg-gray-300 px-3 py-1 border border-black"
            >
              +
            </button>
            {/* Botón "Agregar" con efecto hover usando Ant Design */}
            <button
              onClick={handleAddToCart}
              className="bg-black text-white px-4 py-2 ml-4 transition-colors duration-200 hover:bg-gray-800"
            >
              AGREGAR
            </button>
          </div>

          {/* Miniaturas de imágenes (en el mismo orden que en ProductForm) */}
          <div className="flex mt-6 gap-4">
            {thumbnails.map((img, index) => (
              <img
                key={index}
                src={img}
                alt={`Miniatura ${index + 1}`}
                className="w-20 h-20 border border-black cursor-pointer object-contain p-1"
                onClick={() => handleThumbnailClick(index)}
              />
            ))}
          </div>
        </div>
      </div>

      {/* Sección de descripción e información nutricional */}
      <div className="grid grid-cols-1 md:grid-cols-2 mt-12 gap-8">
        {/* Descripción del producto: usamos el campo description de la API */}
        <div>
          <h2 className="text-xl font-bold">Descripción del producto</h2>
          <p className="text-gray-600 mt-2">{product.description}</p>
        </div>

        {/* Información Nutricional: mostramos el campo nutrition */}
        <div>
          <h2 className="text-xl font-bold">Información Nutricional</h2>
          <div className="mt-2 p-4 border border-gray-300 rounded">
            {/* Si el contenido de nutrition es largo, se puede hacer scroll */}
            <p className="text-gray-700 whitespace-pre-wrap">
              {product.nutrition}
            </p>
          </div>
        </div>
      </div>

      {/* Productos similares */}
      {relatedProducts.length > 0 && (
        <div className="mt-12">
          <h2 className="text-xl font-bold">Productos similares</h2>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
            {relatedProducts.map((relProd) => (
              <Link
                key={relProd.id}
                to={`/product/${relProd.id}`}
                className="p-4 block hover:bg-gray-100 transition rounded-2xl"
              >
                <div className="bg-white w-full h-40 flex items-center justify-center border border-black p-2 rounded-2xl">
                  <img
                    src={relProd.url_img}
                    alt={relProd.product}
                    className="h-full object-contain"
                  />
                </div>
                <p className="mt-2 font-semibold text-center">
                  {relProd.product}
                </p>
              </Link>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

---
---
 // src/pages/ProfilePage.jsx

// src/pages/ProfilePage.jsx

import { useState, useEffect } from "react";
import { useAuth } from "../hooks/useAuth";
import { useNavigate } from "react-router-dom";

// Importa tus componentes Customer
import { MiCuenta } from "../components/customer/MiCuenta";
import { MisPedidos } from "../components/customer/MisPedidos";
import { MisDirecciones } from "../components/customer/MisDirecciones";
import { MisDatos } from "../components/customer/MisDatos";
import { MisFavoritos } from "../components/customer/MisFavoritos";

// Importa los componentes Admin
import { ResumenTienda } from "../components/admin/ResumenTienda";
import { EditarCatalogo } from "../components/admin/EditarCatalogo";
import { PedidosPendientes } from "../components/admin/PedidosPendientes";
import { PedidosHistoricos } from "../components/admin/PedidosHistoricos";
import { EditarUsuarios } from "../components/admin/EditarUsuarios";

export const ProfilePage = () => {
  const { session } = useAuth();
  const navigate = useNavigate();
  const [activeTab, setActiveTab] = useState("mi-cuenta");

  // ✅ Esperar a que la sesión se cargue antes de redirigir
  useEffect(() => {
    if (!session || !session.role) {
      navigate("/"); // Redirigir al Home si no hay sesión o rol inválido
    }
  }, [session, navigate]);

  const isAdmin = session?.role === "admin";

  const tabs = isAdmin
    ? [
        { key: "tab-01", label: "Resumen Tienda", content: <ResumenTienda /> },
        {
          key: "tab-02",
          label: "Editar Catálogo",
          content: <EditarCatalogo />,
        },
        {
          key: "tab-03",
          label: "Pedidos Pendientes",
          content: <PedidosPendientes />,
        },
        {
          key: "tab-04",
          label: "Pedidos Históricos",
          content: <PedidosHistoricos />,
        },
        {
          key: "tab-05",
          label: "Editar Usuarios",
          content: <EditarUsuarios />,
        },
      ]
    : [
        { key: "tab-01", label: "Mi cuenta", content: <MiCuenta /> },
        { key: "tab-02", label: "Mis pedidos", content: <MisPedidos /> },
        {
          key: "tab-03",
          label: "Mis direcciones",
          content: <MisDirecciones />,
        },
        { key: "tab-04", label: "Mis datos", content: <MisDatos /> },
        { key: "tab-05", label: "Mis favoritos", content: <MisFavoritos /> },
      ];

  // ✅ Validar si session aún no se ha cargado completamente
  if (!session || session.role === undefined) {
    return <p className="text-center mt-10">Cargando perfil...</p>;
  }

  return (
    <div className="flex max-h-screen bg-gray-100">
      <aside className="w-1/4 bg-gray-300 p-4 border-r border-black">
        <ul className="space-y-2">
          {tabs.map((tab) => (
            <li key={tab.key}>
              <button
                className={`w-full p-3 text-left border border-black ${
                  activeTab === tab.key ? "bg-white font-bold" : "bg-gray-200"
                }`}
                onClick={() => setActiveTab(tab.key)}
              >
                {tab.label}
              </button>
            </li>
          ))}
        </ul>
      </aside>

      <main className="w-3/4 p-6 bg-white border-l border-black">
        <h2 className="text-xl font-bold mb-4">
          {tabs.find((t) => t.key === activeTab)?.label}
        </h2>
        {tabs.find((t) => t.key === activeTab)?.content}
      </main>
    </div>
  );
};

---
---
 // src/pages/RegisterPage.jsx

// src/pages/RegisterPage.jsx

import { RegisterForm } from "../components/RegisterForm";
import { Link } from "react-router-dom";
import { FcGoogle } from "react-icons/fc";
import { FaFacebook, FaApple } from "react-icons/fa";
import promoData from "../data/promo.json";

export const RegisterPage = () => {
  const promoVideo = new URL(
    `../assets/videos/${promoData.register}`,
    import.meta.url
  ).href;

  return (
    <div
      className="flex items-center justify-center"
      style={{ height: "calc(100vh - 400px)" }}
    >
      {/* Contenedor principal */}
      <div className="aspect-[17/10] w-full max-w-[53.125rem] max-h-[31.25rem] overflow-hidden rounded-xl">
        <div className="flex w-full h-full">
          {/* Sección del login */}
          <div className="w-full lg:w-1/2 bg-gray-100 flex items-center justify-center p-6">
            <div className="max-w-md w-full">
              <h1 className="text-3xl font-semibold mb-6 text-black text-center">
                Registro
              </h1>
              {/* Botones de acceso rápido */}
              <div className="mt-4 flex flex-col lg:flex-row items-center justify-between gap-2">
                <button
                  type="button"
                  className="w-full flex justify-center items-center gap-2 bg-white text-sm text-gray-600 p-2 rounded-md 
                                 hover:bg-gray-50 border border-gray-200 
                                 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-200 
                                 transition-colors duration-300"
                >
                  <FcGoogle size={20} /> Google
                </button>

                <button
                  type="button"
                  className="w-full flex justify-center items-center gap-2 bg-white text-sm text-gray-600 p-2 rounded-md 
                                 hover:bg-gray-50 border border-gray-200 
                                 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-200 
                                 transition-colors duration-300"
                >
                  <FaFacebook size={20} className="text-blue-600" /> Facebook
                </button>

                <button
                  type="button"
                  className="w-full flex justify-center items-center gap-2 bg-white text-sm text-gray-600 p-2 rounded-md 
                                 hover:bg-gray-50 border border-gray-200 
                                 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-200 
                                 transition-colors duration-300"
                >
                  <FaApple size={20} className="text-black" /> Apple
                </button>
              </div>

              <div className="mt-4 text-sm text-gray-600 text-center">
                <p>o con tu correo</p>
              </div>

              <RegisterForm />

              <div className="mt-4 text-sm text-gray-600 text-center">
                <p>
                  ¿Olvidaste tu clave?{" "}
                  <Link
                    to="/auth/reset-password"
                    className="text-black hover:underline"
                  >
                    Resetéala Aquí
                  </Link>
                </p>
              </div>
            </div>
          </div>
          {/* Sección del video */}
          <div className="hidden lg:flex w-1/2 items-center justify-center bg-white text-black">
            <video
              src={promoVideo}
              autoPlay
              loop
              muted
              className="w-full h-full object-cover"
            />
          </div>
        </div>
      </div>
    </div>
  );
};

---
---
 // src/pages/SuccessPage.jsx

// src/pages/SuccessPage.jsx

import { useEffect } from "react";
import { useCart } from "../hooks/useCart";
import { useNavigate } from "react-router-dom";

export const SuccessPage = () => {
  const { clearCart } = useCart();
  const navigate = useNavigate();

  useEffect(() => {
    // Limpia el carrito en el estado global
    clearCart();
    // Si persistes el carrito en localStorage, eliminarlo:
    localStorage.removeItem("cart");
  }, [clearCart]);

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-green-50 p-4">
      <h1 className="text-4xl font-bold mb-4 text-green-700">
        ¡Compra Exitosa!
      </h1>
      <p className="mb-8 text-lg text-green-600">
        Gracias por tu compra. Tu pedido ha sido procesado y será entregado en
        breve.
      </p>
      <button
        onClick={() => {
          // console.log("Navegando a home");
          navigate("/", { replace: true });
        }}
        className="px-6 py-3 bg-green-600 text-white rounded hover:bg-green-700 transition"
      >
        Volver al Inicio
      </button>
    </div>
  );
};

---
---
 // src/router/RouterManager.jsx

// src/router/RouterManager.jsx

import { useAuth } from "../hooks/useAuth";
import { Route, BrowserRouter as Router, Routes } from "react-router-dom";
import { MainLayout } from "../layouts/MainLayout";
import { AuthLayout } from "../layouts/AuthLayout";
import { AuthGuard } from "../guard/AuthGuard";
import { Page404 } from "../pages/Page404";
import { CartPage } from "../pages/CartPage";
import { CheckoutPage } from "../pages/CheckoutPage";
import { HomePage } from "../pages/HomePage";
import { LoginPage } from "../pages/LoginPage";
import { ProfilePage } from "../pages/ProfilePage";
import { RegisterPage } from "../pages/RegisterPage";
import { SuccessPage } from "../pages/SuccessPage";
import { CatalogPage } from "../pages/CatalogPage";
import { ProductPage } from "../pages/ProductPage"; // Importar ProductPage
import { ContactPage } from "../pages/ContactPage"; // Importa la nueva página de contacto
import { roles } from "../helpers/roles";

export const RouterManager = () => {
  const { session } = useAuth();

  return (
    <Router>
      <Routes>
        <Route path="*" element={<Page404 />} />

        {/* Rutas de Autenticación */}
        <Route path="/auth" element={<AuthLayout />}>
          <Route path="login" element={<LoginPage />} />
          <Route path="register" element={<RegisterPage />} />
        </Route>

        {/* Rutas de Usuario con MainLayout */}
        <Route path="/" element={<MainLayout />}>
          <Route index element={<HomePage />} />
          <Route path="cart" element={<CartPage />} />
          <Route path="checkout" element={<CheckoutPage />} />
          <Route path="success" element={<SuccessPage />} />
          <Route path="catalog" element={<CatalogPage />} />
          <Route path="product/:id" element={<ProductPage />} />
          <Route path="contact" element={<ContactPage />} />{" "}
          {/* Nueva ruta para ContactPage */}
          {/* Rutas protegidas por sesión */}
          <Route
            path="profile"
            element={
              <AuthGuard redirectTo="/auth/login" isAllow={session?.token}>
                <ProfilePage />
              </AuthGuard>
            }
          />
        </Route>

        {/* Rutas Exclusivas para Administrador */}
        {session?.role === roles.admin && (
          <Route path="/admin" element={<MainLayout />}></Route>
        )}
      </Routes>
    </Router>
  );
};

---
---
 // vercel.json

{
  "version": 2,
  "builds": [
    {
      "src": "api/index.js",
      "use": "@vercel/node"
    },
    {
      "src": "package.json",
      "use": "@vercel/static-build",
      "config": {
        "distDir": "dist"
      }
    }
  ],
  "routes": [
    { "handle": "filesystem" },
    {
      "src": "/api/(.*)",
      "dest": "/api/index.js"
    },
    {
      "src": "/(.*)",
      "dest": "/index.html"
    }
  ]
}

---
---
 // vite.config.js

import { defineConfig } from 'vite'
import tailwindcss from '@tailwindcss/vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  base: '/',
  plugins: [
    react(),
    tailwindcss(),
  ],
})

---
